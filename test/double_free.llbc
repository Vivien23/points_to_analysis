{"charon_version":"0.1.71","translated":{"crate_name":"double_free","real_crate_name":"double_free","options":{"ullbc":false,"lib":false,"bin":null,"mir_promoted":false,"mir_optimized":false,"crate_name":null,"input_file":null,"read_llbc":null,"dest_dir":null,"dest_file":null,"use_polonius":false,"skip_borrowck":false,"no_code_duplication":false,"extract_opaque_bodies":false,"translate_all_methods":false,"include":[],"opaque":[],"exclude":[],"remove_associated_types":[],"hide_marker_traits":false,"no_cargo":false,"rustc_args":[],"cargo_args":[],"abort_on_error":false,"error_on_warnings":false,"no_serialize":false,"print_original_ullbc":false,"print_ullbc":false,"print_built_llbc":false,"print_llbc":false,"no_merge_goto_chains":false},"all_ids":[{"Fun":0},{"Type":0},{"Type":1},{"Type":2},{"Fun":1},{"TraitDecl":0},{"TraitImpl":0},{"Fun":2},{"TraitDecl":1},{"TraitDecl":2},{"TraitImpl":1},{"Fun":3},{"Fun":4},{"Fun":5},{"Type":3},{"Type":4},{"Type":5},{"Fun":6},{"Fun":7}],"item_names":[{"key":{"Fun":7},"value":[{"Ident":["alloc",0]},{"Ident":["string",0]},{"Impl":[{"Trait":0},44]},{"Ident":["from",0]}]},{"key":{"Fun":1},"value":[{"Ident":["core",0]},{"Ident":["convert",0]},{"Ident":["From",0]},{"Ident":["from",0]}]},{"key":{"TraitDecl":1},"value":[{"Ident":["core",0]},{"Ident":["marker",0]},{"Ident":["Sized",0]}]},{"key":{"Fun":3},"value":[{"Ident":["core",0]},{"Ident":["fmt",0]},{"Impl":[{"Ty":{"params":{"regions":[{"index":0,"name":"'a"}],"types":[],"const_generics":[],"trait_clauses":[],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"skip_binder":{"Adt":[{"Adt":1},{"regions":[{"Var":{"Bound":[0,0]}}],"types":[],"const_generics":[],"trait_refs":[],"target":{"Item":{"Type":1}}}]},"kind":"InherentImplBlock"}},2]},{"Ident":["new_v1",0]}]},{"key":{"Type":0},"value":[{"Ident":["alloc",0]},{"Ident":["string",0]},{"Ident":["String",0]}]},{"key":{"Fun":2},"value":[{"Ident":["core",0]},{"Ident":["fmt",0]},{"Ident":["rt",0]},{"Impl":[{"Ty":{"params":{"regions":[{"index":0,"name":null}],"types":[],"const_generics":[],"trait_clauses":[],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"skip_binder":{"Adt":[{"Adt":2},{"regions":[{"Var":{"Bound":[0,0]}}],"types":[],"const_generics":[],"trait_refs":[],"target":{"Item":{"Type":2}}}]},"kind":"InherentImplBlock"}},1]},{"Ident":["new_display",0]}]},{"key":{"Type":3},"value":[{"Ident":["core",0]},{"Ident":["fmt",0]},{"Ident":["Formatter",0]}]},{"key":{"Fun":6},"value":[{"Ident":["alloc",0]},{"Ident":["string",0]},{"Impl":[{"Trait":1},21]},{"Ident":["fmt",0]}]},{"key":{"Fun":0},"value":[{"Ident":["double_free",0]},{"Ident":["main",0]}]},{"key":{"TraitDecl":2},"value":[{"Ident":["core",0]},{"Ident":["fmt",0]},{"Ident":["Display",0]}]},{"key":{"Fun":4},"value":[{"Ident":["std",0]},{"Ident":["io",0]},{"Ident":["stdio",0]},{"Ident":["_print",0]}]},{"key":{"TraitImpl":1},"value":[{"Ident":["alloc",0]},{"Ident":["string",0]},{"Impl":[{"Trait":1},21]}]},{"key":{"Type":5},"value":[{"Ident":["core",0]},{"Ident":["fmt",0]},{"Ident":["Error",0]}]},{"key":{"Type":1},"value":[{"Ident":["core",0]},{"Ident":["fmt",0]},{"Ident":["Arguments",0]}]},{"key":{"TraitImpl":0},"value":[{"Ident":["alloc",0]},{"Ident":["string",0]},{"Impl":[{"Trait":0},44]}]},{"key":{"Fun":5},"value":[{"Ident":["core",0]},{"Ident":["fmt",0]},{"Ident":["Display",0]},{"Ident":["fmt",0]}]},{"key":{"Type":4},"value":[{"Ident":["core",0]},{"Ident":["result",0]},{"Ident":["Result",0]}]},{"key":{"Type":2},"value":[{"Ident":["core",0]},{"Ident":["fmt",0]},{"Ident":["rt",0]},{"Ident":["Argument",0]}]},{"key":{"TraitDecl":0},"value":[{"Ident":["core",0]},{"Ident":["convert",0]},{"Ident":["From",0]}]}],"files":[{"name":{"Local":"src/double_free.rs"},"contents":"fn main() {\n    let mut x = String::from(\"Helllo\");\n    let y = &mut x;\n    let y = y as *mut _;\n    let z = x; // z has now ownership of \"Hello\", and x should be freed\n    unsafe{ *y = String::from(\"World\")}\n    println!(\"{z}\");\n}"},{"name":{"Virtual":"/rustc/library/alloc/src/string.rs"},"contents":null},{"name":{"Virtual":"/rustc/library/alloc/src/lib.rs"},"contents":null},{"name":{"Virtual":"/rustc/library/std/src/macros.rs"},"contents":null},{"name":{"Virtual":"/rustc/library/core/src/fmt/mod.rs"},"contents":null},{"name":{"Virtual":"/rustc/library/core/src/lib.rs"},"contents":null},{"name":{"Virtual":"/rustc/library/core/src/fmt/rt.rs"},"contents":null},{"name":{"Virtual":"/rustc/library/core/src/convert/mod.rs"},"contents":null},{"name":{"Virtual":"/rustc/library/core/src/marker.rs"},"contents":null},{"name":{"Virtual":"/rustc/library/std/src/io/stdio.rs"},"contents":null},{"name":{"Virtual":"/rustc/library/std/src/lib.rs"},"contents":null},{"name":{"Virtual":"/rustc/library/std/src/io/mod.rs"},"contents":null},{"name":{"Virtual":"/rustc/library/core/src/result.rs"},"contents":null}],"type_decls":[{"def_id":0,"item_meta":{"name":[{"Ident":["alloc",0]},{"Ident":["string",0]},{"Ident":["String",0]}],"span":{"span":{"file_id":1,"beg":{"line":362,"col":0},"end":{"line":362,"col":17}},"generated_from_span":null},"source_text":null,"attr_info":{"attributes":[{"DocComment":" A UTF-8â€“encoded, growable string."},{"DocComment":""},{"DocComment":" `String` is the most common string type. It has ownership over the contents"},{"DocComment":" of the string, stored in a heap-allocated buffer (see [Representation](#representation))."},{"DocComment":" It is closely related to its borrowed counterpart, the primitive [`str`]."},{"DocComment":""},{"DocComment":" # Examples"},{"DocComment":""},{"DocComment":" You can create a `String` from [a literal string][`&str`] with [`String::from`]:"},{"DocComment":""},{"DocComment":" [`String::from`]: From::from"},{"DocComment":""},{"DocComment":" ```"},{"DocComment":" let hello = String::from(\"Hello, world!\");"},{"DocComment":" ```"},{"DocComment":""},{"DocComment":" You can append a [`char`] to a `String` with the [`push`] method, and"},{"DocComment":" append a [`&str`] with the [`push_str`] method:"},{"DocComment":""},{"DocComment":" ```"},{"DocComment":" let mut hello = String::from(\"Hello, \");"},{"DocComment":""},{"DocComment":" hello.push('w');"},{"DocComment":" hello.push_str(\"orld!\");"},{"DocComment":" ```"},{"DocComment":""},{"DocComment":" [`push`]: String::push"},{"DocComment":" [`push_str`]: String::push_str"},{"DocComment":""},{"DocComment":" If you have a vector of UTF-8 bytes, you can create a `String` from it with"},{"DocComment":" the [`from_utf8`] method:"},{"DocComment":""},{"DocComment":" ```"},{"DocComment":" // some bytes, in a vector"},{"DocComment":" let sparkle_heart = vec![240, 159, 146, 150];"},{"DocComment":""},{"DocComment":" // We know these bytes are valid, so we'll use `unwrap()`."},{"DocComment":" let sparkle_heart = String::from_utf8(sparkle_heart).unwrap();"},{"DocComment":""},{"DocComment":" assert_eq!(\"ðŸ’–\", sparkle_heart);"},{"DocComment":" ```"},{"DocComment":""},{"DocComment":" [`from_utf8`]: String::from_utf8"},{"DocComment":""},{"DocComment":" # UTF-8"},{"DocComment":""},{"DocComment":" `String`s are always valid UTF-8. If you need a non-UTF-8 string, consider"},{"DocComment":" [`OsString`]. It is similar, but without the UTF-8 constraint. Because UTF-8"},{"DocComment":" is a variable width encoding, `String`s are typically smaller than an array of"},{"DocComment":" the same `chars`:"},{"DocComment":""},{"DocComment":" ```"},{"DocComment":" use std::mem;"},{"DocComment":""},{"DocComment":" // `s` is ASCII which represents each `char` as one byte"},{"DocComment":" let s = \"hello\";"},{"DocComment":" assert_eq!(s.len(), 5);"},{"DocComment":""},{"DocComment":" // A `char` array with the same contents would be longer because"},{"DocComment":" // every `char` is four bytes"},{"DocComment":" let s = ['h', 'e', 'l', 'l', 'o'];"},{"DocComment":" let size: usize = s.into_iter().map(|c| mem::size_of_val(&c)).sum();"},{"DocComment":" assert_eq!(size, 20);"},{"DocComment":""},{"DocComment":" // However, for non-ASCII strings, the difference will be smaller"},{"DocComment":" // and sometimes they are the same"},{"DocComment":" let s = \"ðŸ’–ðŸ’–ðŸ’–ðŸ’–ðŸ’–\";"},{"DocComment":" assert_eq!(s.len(), 20);"},{"DocComment":""},{"DocComment":" let s = ['ðŸ’–', 'ðŸ’–', 'ðŸ’–', 'ðŸ’–', 'ðŸ’–'];"},{"DocComment":" let size: usize = s.into_iter().map(|c| mem::size_of_val(&c)).sum();"},{"DocComment":" assert_eq!(size, 20);"},{"DocComment":" ```"},{"DocComment":""},{"DocComment":" This raises interesting questions as to how `s[i]` should work."},{"DocComment":" What should `i` be here? Several options include byte indices and"},{"DocComment":" `char` indices but, because of UTF-8 encoding, only byte indices"},{"DocComment":" would provide constant time indexing. Getting the `i`th `char`, for"},{"DocComment":" example, is available using [`chars`]:"},{"DocComment":""},{"DocComment":" ```"},{"DocComment":" let s = \"hello\";"},{"DocComment":" let third_character = s.chars().nth(2);"},{"DocComment":" assert_eq!(third_character, Some('l'));"},{"DocComment":""},{"DocComment":" let s = \"ðŸ’–ðŸ’–ðŸ’–ðŸ’–ðŸ’–\";"},{"DocComment":" let third_character = s.chars().nth(2);"},{"DocComment":" assert_eq!(third_character, Some('ðŸ’–'));"},{"DocComment":" ```"},{"DocComment":""},{"DocComment":" Next, what should `s[i]` return? Because indexing returns a reference"},{"DocComment":" to underlying data it could be `&u8`, `&[u8]`, or something else similar."},{"DocComment":" Since we're only providing one index, `&u8` makes the most sense but that"},{"DocComment":" might not be what the user expects and can be explicitly achieved with"},{"DocComment":" [`as_bytes()`]:"},{"DocComment":""},{"DocComment":" ```"},{"DocComment":" // The first byte is 104 - the byte value of `'h'`"},{"DocComment":" let s = \"hello\";"},{"DocComment":" assert_eq!(s.as_bytes()[0], 104);"},{"DocComment":" // or"},{"DocComment":" assert_eq!(s.as_bytes()[0], b'h');"},{"DocComment":""},{"DocComment":" // The first byte is 240 which isn't obviously useful"},{"DocComment":" let s = \"ðŸ’–ðŸ’–ðŸ’–ðŸ’–ðŸ’–\";"},{"DocComment":" assert_eq!(s.as_bytes()[0], 240);"},{"DocComment":" ```"},{"DocComment":""},{"DocComment":" Due to these ambiguities/restrictions, indexing with a `usize` is simply"},{"DocComment":" forbidden:"},{"DocComment":""},{"DocComment":" ```compile_fail,E0277"},{"DocComment":" let s = \"hello\";"},{"DocComment":""},{"DocComment":" // The following will not compile!"},{"DocComment":" println!(\"The first letter of s is {}\", s[0]);"},{"DocComment":" ```"},{"DocComment":""},{"DocComment":" It is more clear, however, how `&s[i..j]` should work (that is,"},{"DocComment":" indexing with a range). It should accept byte indices (to be constant-time)"},{"DocComment":" and return a `&str` which is UTF-8 encoded. This is also called \"string slicing\"."},{"DocComment":" Note this will panic if the byte indices provided are not character"},{"DocComment":" boundaries - see [`is_char_boundary`] for more details. See the implementations"},{"DocComment":" for [`SliceIndex<str>`] for more details on string slicing. For a non-panicking"},{"DocComment":" version of string slicing, see [`get`]."},{"DocComment":""},{"DocComment":" [`OsString`]: ../../std/ffi/struct.OsString.html \"ffi::OsString\""},{"DocComment":" [`SliceIndex<str>`]: core::slice::SliceIndex"},{"DocComment":" [`as_bytes()`]: str::as_bytes"},{"DocComment":" [`get`]: str::get"},{"DocComment":" [`is_char_boundary`]: str::is_char_boundary"},{"DocComment":""},{"DocComment":" The [`bytes`] and [`chars`] methods return iterators over the bytes and"},{"DocComment":" codepoints of the string, respectively. To iterate over codepoints along"},{"DocComment":" with byte indices, use [`char_indices`]."},{"DocComment":""},{"DocComment":" [`bytes`]: str::bytes"},{"DocComment":" [`chars`]: str::chars"},{"DocComment":" [`char_indices`]: str::char_indices"},{"DocComment":""},{"DocComment":" # Deref"},{"DocComment":""},{"DocComment":" `String` implements <code>[Deref]<Target = [str]></code>, and so inherits all of [`str`]'s"},{"DocComment":" methods. In addition, this means that you can pass a `String` to a"},{"DocComment":" function which takes a [`&str`] by using an ampersand (`&`):"},{"DocComment":""},{"DocComment":" ```"},{"DocComment":" fn takes_str(s: &str) { }"},{"DocComment":""},{"DocComment":" let s = String::from(\"Hello\");"},{"DocComment":""},{"DocComment":" takes_str(&s);"},{"DocComment":" ```"},{"DocComment":""},{"DocComment":" This will create a [`&str`] from the `String` and pass it in. This"},{"DocComment":" conversion is very inexpensive, and so generally, functions will accept"},{"DocComment":" [`&str`]s as arguments unless they need a `String` for some specific"},{"DocComment":" reason."},{"DocComment":""},{"DocComment":" In certain cases Rust doesn't have enough information to make this"},{"DocComment":" conversion, known as [`Deref`] coercion. In the following example a string"},{"DocComment":" slice [`&'a str`][`&str`] implements the trait `TraitExample`, and the function"},{"DocComment":" `example_func` takes anything that implements the trait. In this case Rust"},{"DocComment":" would need to make two implicit conversions, which Rust doesn't have the"},{"DocComment":" means to do. For that reason, the following example will not compile."},{"DocComment":""},{"DocComment":" ```compile_fail,E0277"},{"DocComment":" trait TraitExample {}"},{"DocComment":""},{"DocComment":" impl<'a> TraitExample for &'a str {}"},{"DocComment":""},{"DocComment":" fn example_func<A: TraitExample>(example_arg: A) {}"},{"DocComment":""},{"DocComment":" let example_string = String::from(\"example_string\");"},{"DocComment":" example_func(&example_string);"},{"DocComment":" ```"},{"DocComment":""},{"DocComment":" There are two options that would work instead. The first would be to"},{"DocComment":" change the line `example_func(&example_string);` to"},{"DocComment":" `example_func(example_string.as_str());`, using the method [`as_str()`]"},{"DocComment":" to explicitly extract the string slice containing the string. The second"},{"DocComment":" way changes `example_func(&example_string);` to"},{"DocComment":" `example_func(&*example_string);`. In this case we are dereferencing a"},{"DocComment":" `String` to a [`str`], then referencing the [`str`] back to"},{"DocComment":" [`&str`]. The second way is more idiomatic, however both work to do the"},{"DocComment":" conversion explicitly rather than relying on the implicit conversion."},{"DocComment":""},{"DocComment":" # Representation"},{"DocComment":""},{"DocComment":" A `String` is made up of three components: a pointer to some bytes, a"},{"DocComment":" length, and a capacity. The pointer points to the internal buffer which `String`"},{"DocComment":" uses to store its data. The length is the number of bytes currently stored"},{"DocComment":" in the buffer, and the capacity is the size of the buffer in bytes. As such,"},{"DocComment":" the length will always be less than or equal to the capacity."},{"DocComment":""},{"DocComment":" This buffer is always stored on the heap."},{"DocComment":""},{"DocComment":" You can look at these with the [`as_ptr`], [`len`], and [`capacity`]"},{"DocComment":" methods:"},{"DocComment":""},{"DocComment":" ```"},{"DocComment":" use std::mem;"},{"DocComment":""},{"DocComment":" let story = String::from(\"Once upon a time...\");"},{"DocComment":""},{"DocComment":" // Prevent automatically dropping the String's data"},{"DocComment":" let mut story = mem::ManuallyDrop::new(story);"},{"DocComment":""},{"DocComment":" let ptr = story.as_mut_ptr();"},{"DocComment":" let len = story.len();"},{"DocComment":" let capacity = story.capacity();"},{"DocComment":""},{"DocComment":" // story has nineteen bytes"},{"DocComment":" assert_eq!(19, len);"},{"DocComment":""},{"DocComment":" // We can re-build a String out of ptr, len, and capacity. This is all"},{"DocComment":" // unsafe because we are responsible for making sure the components are"},{"DocComment":" // valid:"},{"DocComment":" let s = unsafe { String::from_raw_parts(ptr, len, capacity) } ;"},{"DocComment":""},{"DocComment":" assert_eq!(String::from(\"Once upon a time...\"), s);"},{"DocComment":" ```"},{"DocComment":""},{"DocComment":" [`as_ptr`]: str::as_ptr"},{"DocComment":" [`len`]: String::len"},{"DocComment":" [`capacity`]: String::capacity"},{"DocComment":""},{"DocComment":" If a `String` has enough capacity, adding elements to it will not"},{"DocComment":" re-allocate. For example, consider this program:"},{"DocComment":""},{"DocComment":" ```"},{"DocComment":" let mut s = String::new();"},{"DocComment":""},{"DocComment":" println!(\"{}\", s.capacity());"},{"DocComment":""},{"DocComment":" for _ in 0..5 {"},{"DocComment":"     s.push_str(\"hello\");"},{"DocComment":"     println!(\"{}\", s.capacity());"},{"DocComment":" }"},{"DocComment":" ```"},{"DocComment":""},{"DocComment":" This will output the following:"},{"DocComment":""},{"DocComment":" ```text"},{"DocComment":" 0"},{"DocComment":" 8"},{"DocComment":" 16"},{"DocComment":" 16"},{"DocComment":" 32"},{"DocComment":" 32"},{"DocComment":" ```"},{"DocComment":""},{"DocComment":" At first, we have no memory allocated at all, but as we append to the"},{"DocComment":" string, it increases its capacity appropriately. If we instead use the"},{"DocComment":" [`with_capacity`] method to allocate the correct capacity initially:"},{"DocComment":""},{"DocComment":" ```"},{"DocComment":" let mut s = String::with_capacity(25);"},{"DocComment":""},{"DocComment":" println!(\"{}\", s.capacity());"},{"DocComment":""},{"DocComment":" for _ in 0..5 {"},{"DocComment":"     s.push_str(\"hello\");"},{"DocComment":"     println!(\"{}\", s.capacity());"},{"DocComment":" }"},{"DocComment":" ```"},{"DocComment":""},{"DocComment":" [`with_capacity`]: String::with_capacity"},{"DocComment":""},{"DocComment":" We end up with a different output:"},{"DocComment":""},{"DocComment":" ```text"},{"DocComment":" 25"},{"DocComment":" 25"},{"DocComment":" 25"},{"DocComment":" 25"},{"DocComment":" 25"},{"DocComment":" 25"},{"DocComment":" ```"},{"DocComment":""},{"DocComment":" Here, there's no need to allocate more memory inside the loop."},{"DocComment":""},{"DocComment":" [str]: prim@str \"str\""},{"DocComment":" [`str`]: prim@str \"str\""},{"DocComment":" [`&str`]: prim@str \"&str\""},{"DocComment":" [Deref]: core::ops::Deref \"ops::Deref\""},{"DocComment":" [`Deref`]: core::ops::Deref \"ops::Deref\""},{"DocComment":" [`as_str()`]: String::as_str"}],"inline":null,"rename":null,"public":true},"is_local":false,"opacity":"Foreign","lang_item":"String"},"generics":{"regions":[],"types":[],"const_generics":[],"trait_clauses":[],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"kind":"Opaque"},{"def_id":1,"item_meta":{"name":[{"Ident":["core",0]},{"Ident":["fmt",0]},{"Ident":["Arguments",0]}],"span":{"span":{"file_id":4,"beg":{"line":319,"col":0},"end":{"line":319,"col":24}},"generated_from_span":null},"source_text":null,"attr_info":{"attributes":[{"DocComment":" This structure represents a safely precompiled version of a format string"},{"DocComment":" and its arguments. This cannot be generated at runtime because it cannot"},{"DocComment":" safely be done, so no constructors are given and the fields are private"},{"DocComment":" to prevent modification."},{"DocComment":""},{"DocComment":" The [`format_args!`] macro will safely create an instance of this structure."},{"DocComment":" The macro validates the format string at compile-time so usage of the"},{"DocComment":" [`write()`] and [`format()`] functions can be safely performed."},{"DocComment":""},{"DocComment":" You can use the `Arguments<'a>` that [`format_args!`] returns in `Debug`"},{"DocComment":" and `Display` contexts as seen below. The example also shows that `Debug`"},{"DocComment":" and `Display` format to the same thing: the interpolated format string"},{"DocComment":" in `format_args!`."},{"DocComment":""},{"DocComment":" ```rust"},{"DocComment":" let debug = format!(\"{:?}\", format_args!(\"{} foo {:?}\", 1, 2));"},{"DocComment":" let display = format!(\"{}\", format_args!(\"{} foo {:?}\", 1, 2));"},{"DocComment":" assert_eq!(\"1 foo 2\", display);"},{"DocComment":" assert_eq!(display, debug);"},{"DocComment":" ```"},{"DocComment":""},{"DocComment":" [`format()`]: ../../std/fmt/fn.format.html"}],"inline":null,"rename":null,"public":true},"is_local":false,"opacity":"Foreign","lang_item":"format_arguments"},"generics":{"regions":[{"index":0,"name":"'a"}],"types":[],"const_generics":[],"trait_clauses":[],"regions_outlive":[{"regions":[],"skip_binder":[{"Var":{"Free":0}},{"Var":{"Free":0}}]}],"types_outlive":[],"trait_type_constraints":[]},"kind":"Opaque"},{"def_id":2,"item_meta":{"name":[{"Ident":["core",0]},{"Ident":["fmt",0]},{"Ident":["rt",0]},{"Ident":["Argument",0]}],"span":{"span":{"file_id":6,"beg":{"line":92,"col":0},"end":{"line":92,"col":23}},"generated_from_span":null},"source_text":null,"attr_info":{"attributes":[],"inline":null,"rename":null,"public":true},"is_local":false,"opacity":"Foreign","lang_item":"format_argument"},"generics":{"regions":[{"index":0,"name":"'a"}],"types":[],"const_generics":[],"trait_clauses":[],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"kind":"Opaque"},{"def_id":3,"item_meta":{"name":[{"Ident":["core",0]},{"Ident":["fmt",0]},{"Ident":["Formatter",0]}],"span":{"span":{"file_id":4,"beg":{"line":262,"col":0},"end":{"line":262,"col":24}},"generated_from_span":null},"source_text":null,"attr_info":{"attributes":[{"DocComment":" Configuration for formatting."},{"DocComment":""},{"DocComment":" A `Formatter` represents various options related to formatting. Users do not"},{"DocComment":" construct `Formatter`s directly; a mutable reference to one is passed to"},{"DocComment":" the `fmt` method of all formatting traits, like [`Debug`] and [`Display`]."},{"DocComment":""},{"DocComment":" To interact with a `Formatter`, you'll call various methods to change the"},{"DocComment":" various options related to formatting. For examples, please see the"},{"DocComment":" documentation of the methods defined on `Formatter` below."},{"Unknown":{"path":"rustc_diagnostic_item","args":null}}],"inline":null,"rename":null,"public":true},"is_local":false,"opacity":"Foreign","lang_item":"Formatter"},"generics":{"regions":[{"index":0,"name":"'a"}],"types":[],"const_generics":[],"trait_clauses":[],"regions_outlive":[{"regions":[],"skip_binder":[{"Var":{"Free":0}},{"Var":{"Free":0}}]}],"types_outlive":[],"trait_type_constraints":[]},"kind":"Opaque"},{"def_id":4,"item_meta":{"name":[{"Ident":["core",0]},{"Ident":["result",0]},{"Ident":["Result",0]}],"span":{"span":{"file_id":12,"beg":{"line":527,"col":0},"end":{"line":527,"col":21}},"generated_from_span":null},"source_text":null,"attr_info":{"attributes":[{"DocComment":" `Result` is a type that represents either success ([`Ok`]) or failure ([`Err`])."},{"DocComment":""},{"DocComment":" See the [module documentation](self) for details."},{"Unknown":{"path":"must_use","args":null}},{"Unknown":{"path":"rustc_diagnostic_item","args":null}}],"inline":null,"rename":null,"public":true},"is_local":false,"opacity":"Foreign","lang_item":"Result"},"generics":{"regions":[],"types":[{"index":0,"name":"T"},{"index":1,"name":"E"}],"const_generics":[],"trait_clauses":[{"clause_id":0,"span":{"span":{"file_id":12,"beg":{"line":527,"col":16},"end":{"line":527,"col":17}},"generated_from_span":null},"origin":"WhereClauseOnType","trait_":{"regions":[],"skip_binder":{"trait_id":1,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}}],"const_generics":[],"trait_refs":[],"target":{"Item":{"TraitDecl":1}}}}}},{"clause_id":1,"span":{"span":{"file_id":12,"beg":{"line":527,"col":19},"end":{"line":527,"col":20}},"generated_from_span":null},"origin":"WhereClauseOnType","trait_":{"regions":[],"skip_binder":{"trait_id":1,"generics":{"regions":[],"types":[{"TypeVar":{"Free":1}}],"const_generics":[],"trait_refs":[],"target":{"Item":{"TraitDecl":1}}}}}}],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"kind":{"Enum":[{"span":{"span":{"file_id":12,"beg":{"line":531,"col":4},"end":{"line":531,"col":6}},"generated_from_span":null},"attr_info":{"attributes":[{"DocComment":" Contains the success value"}],"inline":null,"rename":null,"public":true},"name":"Ok","fields":[{"span":{"span":{"file_id":12,"beg":{"line":531,"col":53},"end":{"line":531,"col":54}},"generated_from_span":null},"attr_info":{"attributes":[],"inline":null,"rename":null,"public":true},"name":null,"ty":{"TypeVar":{"Free":0}}}],"discriminant":{"Isize":"0"}},{"span":{"span":{"file_id":12,"beg":{"line":536,"col":4},"end":{"line":536,"col":7}},"generated_from_span":null},"attr_info":{"attributes":[{"DocComment":" Contains the error value"}],"inline":null,"rename":null,"public":true},"name":"Err","fields":[{"span":{"span":{"file_id":12,"beg":{"line":536,"col":54},"end":{"line":536,"col":55}},"generated_from_span":null},"attr_info":{"attributes":[],"inline":null,"rename":null,"public":true},"name":null,"ty":{"TypeVar":{"Free":1}}}],"discriminant":{"Isize":"1"}}]}},{"def_id":5,"item_meta":{"name":[{"Ident":["core",0]},{"Ident":["fmt",0]},{"Ident":["Error",0]}],"span":{"span":{"file_id":4,"beg":{"line":103,"col":0},"end":{"line":103,"col":16}},"generated_from_span":null},"source_text":null,"attr_info":{"attributes":[{"DocComment":" The error type which is returned from formatting a message into a stream."},{"DocComment":""},{"DocComment":" This type does not support transmission of an error other than that an error"},{"DocComment":" occurred. This is because, despite the existence of this error,"},{"DocComment":" string formatting is considered an infallible operation."},{"DocComment":" `fmt()` implementors should not return this `Error` unless they received it from their"},{"DocComment":" [`Formatter`]. The only time your code should create a new instance of this"},{"DocComment":" error is when implementing `fmt::Write`, in order to cancel the formatting operation when"},{"DocComment":" writing to the underlying stream fails."},{"DocComment":""},{"DocComment":" Any extra information must be arranged to be transmitted through some other means,"},{"DocComment":" such as storing it in a field to be consulted after the formatting operation has been"},{"DocComment":" cancelled. (For example, this is how [`std::io::Write::write_fmt()`] propagates IO errors"},{"DocComment":" during writing.)"},{"DocComment":""},{"DocComment":" This type, `fmt::Error`, should not be"},{"DocComment":" confused with [`std::io::Error`] or [`std::error::Error`], which you may also"},{"DocComment":" have in scope."},{"DocComment":""},{"DocComment":" [`std::io::Error`]: ../../std/io/struct.Error.html"},{"DocComment":" [`std::io::Write::write_fmt()`]: ../../std/io/trait.Write.html#method.write_fmt"},{"DocComment":" [`std::error::Error`]: ../../std/error/trait.Error.html"},{"DocComment":""},{"DocComment":" # Examples"},{"DocComment":""},{"DocComment":" ```rust"},{"DocComment":" use std::fmt::{self, write};"},{"DocComment":""},{"DocComment":" let mut output = String::new();"},{"DocComment":" if let Err(fmt::Error) = write(&mut output, format_args!(\"Hello {}!\", \"world\")) {"},{"DocComment":"     panic!(\"An error occurred\");"},{"DocComment":" }"},{"DocComment":" ```"}],"inline":null,"rename":null,"public":true},"is_local":false,"opacity":"Foreign","lang_item":null},"generics":{"regions":[],"types":[],"const_generics":[],"trait_clauses":[],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"kind":{"Struct":[]}}],"fun_decls":[{"def_id":0,"item_meta":{"name":[{"Ident":["double_free",0]},{"Ident":["main",0]}],"span":{"span":{"file_id":0,"beg":{"line":1,"col":0},"end":{"line":8,"col":1}},"generated_from_span":null},"source_text":"fn main() {\n    let mut x = String::from(\"Helllo\");\n    let y = &mut x;\n    let y = y as *mut _;\n    let z = x; // z has now ownership of \"Hello\", and x should be freed\n    unsafe{ *y = String::from(\"World\")}\n    println!(\"{z}\");\n}","attr_info":{"attributes":[],"inline":null,"rename":null,"public":false},"is_local":true,"opacity":"Transparent","lang_item":null},"signature":{"is_unsafe":false,"is_closure":false,"closure_info":null,"generics":{"regions":[],"types":[],"const_generics":[],"trait_clauses":[],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"inputs":[],"output":{"Adt":["Tuple",{"regions":[],"types":[],"const_generics":[],"trait_refs":[],"target":"Builtin"}]}},"kind":"Regular","is_global_initializer":null,"body":{"Ok":{"Structured":{"span":{"span":{"file_id":0,"beg":{"line":1,"col":0},"end":{"line":8,"col":1}},"generated_from_span":null},"locals":{"arg_count":0,"vars":[{"index":0,"name":null,"ty":{"Adt":["Tuple",{"regions":[],"types":[],"const_generics":[],"trait_refs":[],"target":"Builtin"}]}},{"index":1,"name":"x","ty":{"Adt":[{"Adt":0},{"regions":[],"types":[],"const_generics":[],"trait_refs":[],"target":{"Item":{"Type":0}}}]}},{"index":2,"name":"y","ty":{"Ref":["Erased",{"Adt":[{"Adt":0},{"regions":[],"types":[],"const_generics":[],"trait_refs":[],"target":{"Item":{"Type":0}}}]},"Mut"]}},{"index":3,"name":"y","ty":{"RawPtr":[{"Adt":[{"Adt":0},{"regions":[],"types":[],"const_generics":[],"trait_refs":[],"target":{"Item":{"Type":0}}}]},"Mut"]}},{"index":4,"name":null,"ty":{"RawPtr":[{"Adt":[{"Adt":0},{"regions":[],"types":[],"const_generics":[],"trait_refs":[],"target":{"Item":{"Type":0}}}]},"Mut"]}},{"index":5,"name":"z","ty":{"Adt":[{"Adt":0},{"regions":[],"types":[],"const_generics":[],"trait_refs":[],"target":{"Item":{"Type":0}}}]}},{"index":6,"name":null,"ty":{"Adt":["Tuple",{"regions":[],"types":[],"const_generics":[],"trait_refs":[],"target":"Builtin"}]}},{"index":7,"name":null,"ty":{"Adt":[{"Adt":0},{"regions":[],"types":[],"const_generics":[],"trait_refs":[],"target":{"Item":{"Type":0}}}]}},{"index":8,"name":null,"ty":{"Adt":["Tuple",{"regions":[],"types":[],"const_generics":[],"trait_refs":[],"target":"Builtin"}]}},{"index":9,"name":null,"ty":{"Adt":["Tuple",{"regions":[],"types":[],"const_generics":[],"trait_refs":[],"target":"Builtin"}]}},{"index":10,"name":null,"ty":{"Adt":[{"Adt":1},{"regions":["Erased"],"types":[],"const_generics":[],"trait_refs":[],"target":{"Item":{"Type":1}}}]}},{"index":11,"name":null,"ty":{"Ref":["Erased",{"Adt":[{"Builtin":"Array"},{"regions":[],"types":[{"Ref":["Erased",{"Adt":[{"Builtin":"Str"},{"regions":[],"types":[],"const_generics":[],"trait_refs":[],"target":"Builtin"}]},"Shared"]}],"const_generics":[{"Value":{"Scalar":{"Usize":"2"}}}],"trait_refs":[],"target":"Builtin"}]},"Shared"]}},{"index":12,"name":null,"ty":{"Ref":["Erased",{"Adt":[{"Builtin":"Array"},{"regions":[],"types":[{"Ref":["Erased",{"Adt":[{"Builtin":"Str"},{"regions":[],"types":[],"const_generics":[],"trait_refs":[],"target":"Builtin"}]},"Shared"]}],"const_generics":[{"Value":{"Scalar":{"Usize":"2"}}}],"trait_refs":[],"target":"Builtin"}]},"Shared"]}},{"index":13,"name":null,"ty":{"Adt":[{"Builtin":"Array"},{"regions":[],"types":[{"Ref":["Erased",{"Adt":[{"Builtin":"Str"},{"regions":[],"types":[],"const_generics":[],"trait_refs":[],"target":"Builtin"}]},"Shared"]}],"const_generics":[{"Value":{"Scalar":{"Usize":"2"}}}],"trait_refs":[],"target":"Builtin"}]}},{"index":14,"name":null,"ty":{"Ref":["Erased",{"Adt":[{"Builtin":"Array"},{"regions":[],"types":[{"Adt":[{"Adt":2},{"regions":["Erased"],"types":[],"const_generics":[],"trait_refs":[],"target":{"Item":{"Type":2}}}]}],"const_generics":[{"Value":{"Scalar":{"Usize":"1"}}}],"trait_refs":[],"target":"Builtin"}]},"Shared"]}},{"index":15,"name":null,"ty":{"Ref":["Erased",{"Adt":[{"Builtin":"Array"},{"regions":[],"types":[{"Adt":[{"Adt":2},{"regions":["Erased"],"types":[],"const_generics":[],"trait_refs":[],"target":{"Item":{"Type":2}}}]}],"const_generics":[{"Value":{"Scalar":{"Usize":"1"}}}],"trait_refs":[],"target":"Builtin"}]},"Shared"]}},{"index":16,"name":null,"ty":{"Adt":[{"Builtin":"Array"},{"regions":[],"types":[{"Adt":[{"Adt":2},{"regions":["Erased"],"types":[],"const_generics":[],"trait_refs":[],"target":{"Item":{"Type":2}}}]}],"const_generics":[{"Value":{"Scalar":{"Usize":"1"}}}],"trait_refs":[],"target":"Builtin"}]}},{"index":17,"name":null,"ty":{"Adt":[{"Adt":2},{"regions":["Erased"],"types":[],"const_generics":[],"trait_refs":[],"target":{"Item":{"Type":2}}}]}},{"index":18,"name":null,"ty":{"Ref":["Erased",{"Adt":[{"Adt":0},{"regions":[],"types":[],"const_generics":[],"trait_refs":[],"target":{"Item":{"Type":0}}}]},"Shared"]}},{"index":19,"name":null,"ty":{"Ref":["Erased",{"Adt":[{"Adt":0},{"regions":[],"types":[],"const_generics":[],"trait_refs":[],"target":{"Item":{"Type":0}}}]},"Shared"]}}]},"comments":[],"body":{"span":{"span":{"file_id":0,"beg":{"line":1,"col":10},"end":{"line":8,"col":1}},"generated_from_span":null},"statements":[{"span":{"span":{"file_id":0,"beg":{"line":2,"col":16},"end":{"line":2,"col":38}},"generated_from_span":null},"content":{"Call":{"func":{"Regular":{"func":{"Fun":{"Regular":7}},"generics":{"regions":["Erased"],"types":[],"const_generics":[],"trait_refs":[],"target":{"Item":{"Fun":7}}}}},"args":[{"Const":{"value":{"Literal":{"Str":"Helllo"}},"ty":{"Ref":["Erased",{"Adt":[{"Builtin":"Str"},{"regions":[],"types":[],"const_generics":[],"trait_refs":[],"target":"Builtin"}]},"Shared"]}}}],"dest":{"kind":{"Base":1},"ty":{"Adt":[{"Adt":0},{"regions":[],"types":[],"const_generics":[],"trait_refs":[],"target":{"Item":{"Type":0}}}]}}}},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":2,"col":8},"end":{"line":2,"col":13}},"generated_from_span":null},"content":{"FakeRead":{"kind":{"Base":1},"ty":{"Adt":[{"Adt":0},{"regions":[],"types":[],"const_generics":[],"trait_refs":[],"target":{"Item":{"Type":0}}}]}}},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":3,"col":12},"end":{"line":3,"col":18}},"generated_from_span":null},"content":{"Assign":[{"kind":{"Base":2},"ty":{"Ref":["Erased",{"Adt":[{"Adt":0},{"regions":[],"types":[],"const_generics":[],"trait_refs":[],"target":{"Item":{"Type":0}}}]},"Mut"]}},{"Ref":[{"kind":{"Base":1},"ty":{"Adt":[{"Adt":0},{"regions":[],"types":[],"const_generics":[],"trait_refs":[],"target":{"Item":{"Type":0}}}]}},"Mut"]}]},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":3,"col":8},"end":{"line":3,"col":9}},"generated_from_span":null},"content":{"FakeRead":{"kind":{"Base":2},"ty":{"Ref":["Erased",{"Adt":[{"Adt":0},{"regions":[],"types":[],"const_generics":[],"trait_refs":[],"target":{"Item":{"Type":0}}}]},"Mut"]}}},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":4,"col":12},"end":{"line":4,"col":13}},"generated_from_span":null},"content":{"Assign":[{"kind":{"Base":4},"ty":{"RawPtr":[{"Adt":[{"Adt":0},{"regions":[],"types":[],"const_generics":[],"trait_refs":[],"target":{"Item":{"Type":0}}}]},"Mut"]}},{"RawPtr":[{"kind":{"Projection":[{"kind":{"Base":2},"ty":{"Ref":["Erased",{"Adt":[{"Adt":0},{"regions":[],"types":[],"const_generics":[],"trait_refs":[],"target":{"Item":{"Type":0}}}]},"Mut"]}},"Deref"]},"ty":{"Adt":[{"Adt":0},{"regions":[],"types":[],"const_generics":[],"trait_refs":[],"target":{"Item":{"Type":0}}}]}},"Mut"]}]},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":4,"col":12},"end":{"line":4,"col":23}},"generated_from_span":null},"content":{"Assign":[{"kind":{"Base":3},"ty":{"RawPtr":[{"Adt":[{"Adt":0},{"regions":[],"types":[],"const_generics":[],"trait_refs":[],"target":{"Item":{"Type":0}}}]},"Mut"]}},{"Use":{"Copy":{"kind":{"Base":4},"ty":{"RawPtr":[{"Adt":[{"Adt":0},{"regions":[],"types":[],"const_generics":[],"trait_refs":[],"target":{"Item":{"Type":0}}}]},"Mut"]}}}}]},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":4,"col":8},"end":{"line":4,"col":9}},"generated_from_span":null},"content":{"FakeRead":{"kind":{"Base":3},"ty":{"RawPtr":[{"Adt":[{"Adt":0},{"regions":[],"types":[],"const_generics":[],"trait_refs":[],"target":{"Item":{"Type":0}}}]},"Mut"]}}},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":4,"col":23},"end":{"line":4,"col":24}},"generated_from_span":null},"content":{"Drop":{"kind":{"Base":4},"ty":{"RawPtr":[{"Adt":[{"Adt":0},{"regions":[],"types":[],"const_generics":[],"trait_refs":[],"target":{"Item":{"Type":0}}}]},"Mut"]}}},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":5,"col":12},"end":{"line":5,"col":13}},"generated_from_span":null},"content":{"Assign":[{"kind":{"Base":5},"ty":{"Adt":[{"Adt":0},{"regions":[],"types":[],"const_generics":[],"trait_refs":[],"target":{"Item":{"Type":0}}}]}},{"Use":{"Move":{"kind":{"Base":1},"ty":{"Adt":[{"Adt":0},{"regions":[],"types":[],"const_generics":[],"trait_refs":[],"target":{"Item":{"Type":0}}}]}}}}]},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":5,"col":8},"end":{"line":5,"col":9}},"generated_from_span":null},"content":{"FakeRead":{"kind":{"Base":5},"ty":{"Adt":[{"Adt":0},{"regions":[],"types":[],"const_generics":[],"trait_refs":[],"target":{"Item":{"Type":0}}}]}}},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":6,"col":17},"end":{"line":6,"col":38}},"generated_from_span":null},"content":{"Call":{"func":{"Regular":{"func":{"Fun":{"Regular":7}},"generics":{"regions":["Erased"],"types":[],"const_generics":[],"trait_refs":[],"target":{"Item":{"Fun":7}}}}},"args":[{"Const":{"value":{"Literal":{"Str":"World"}},"ty":{"Ref":["Erased",{"Adt":[{"Builtin":"Str"},{"regions":[],"types":[],"const_generics":[],"trait_refs":[],"target":"Builtin"}]},"Shared"]}}}],"dest":{"kind":{"Base":7},"ty":{"Adt":[{"Adt":0},{"regions":[],"types":[],"const_generics":[],"trait_refs":[],"target":{"Item":{"Type":0}}}]}}}},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":6,"col":12},"end":{"line":6,"col":14}},"generated_from_span":null},"content":{"Drop":{"kind":{"Projection":[{"kind":{"Base":3},"ty":{"RawPtr":[{"Adt":[{"Adt":0},{"regions":[],"types":[],"const_generics":[],"trait_refs":[],"target":{"Item":{"Type":0}}}]},"Mut"]}},"Deref"]},"ty":{"Adt":[{"Adt":0},{"regions":[],"types":[],"const_generics":[],"trait_refs":[],"target":{"Item":{"Type":0}}}]}}},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":6,"col":12},"end":{"line":6,"col":14}},"generated_from_span":null},"content":{"Assign":[{"kind":{"Projection":[{"kind":{"Base":3},"ty":{"RawPtr":[{"Adt":[{"Adt":0},{"regions":[],"types":[],"const_generics":[],"trait_refs":[],"target":{"Item":{"Type":0}}}]},"Mut"]}},"Deref"]},"ty":{"Adt":[{"Adt":0},{"regions":[],"types":[],"const_generics":[],"trait_refs":[],"target":{"Item":{"Type":0}}}]}},{"Use":{"Move":{"kind":{"Base":7},"ty":{"Adt":[{"Adt":0},{"regions":[],"types":[],"const_generics":[],"trait_refs":[],"target":{"Item":{"Type":0}}}]}}}}]},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":6,"col":37},"end":{"line":6,"col":38}},"generated_from_span":null},"content":{"Drop":{"kind":{"Base":7},"ty":{"Adt":[{"Adt":0},{"regions":[],"types":[],"const_generics":[],"trait_refs":[],"target":{"Item":{"Type":0}}}]}}},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":6,"col":37},"end":{"line":6,"col":38}},"generated_from_span":null},"content":{"Drop":{"kind":{"Base":7},"ty":{"Adt":[{"Adt":0},{"regions":[],"types":[],"const_generics":[],"trait_refs":[],"target":{"Item":{"Type":0}}}]}}},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":6,"col":38},"end":{"line":6,"col":39}},"generated_from_span":null},"content":{"Drop":{"kind":{"Base":6},"ty":{"Adt":["Tuple",{"regions":[],"types":[],"const_generics":[],"trait_refs":[],"target":"Builtin"}]}}},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":7,"col":13},"end":{"line":7,"col":18}},"generated_from_span":null},"content":{"Assign":[{"kind":{"Base":13},"ty":{"Adt":[{"Builtin":"Array"},{"regions":[],"types":[{"Ref":["Erased",{"Adt":[{"Builtin":"Str"},{"regions":[],"types":[],"const_generics":[],"trait_refs":[],"target":"Builtin"}]},"Shared"]}],"const_generics":[{"Value":{"Scalar":{"Usize":"2"}}}],"trait_refs":[],"target":"Builtin"}]}},{"Aggregate":[{"Array":[{"Ref":["Erased",{"Adt":[{"Builtin":"Str"},{"regions":[],"types":[],"const_generics":[],"trait_refs":[],"target":"Builtin"}]},"Shared"]},{"Value":{"Scalar":{"Usize":"2"}}}]},[{"Const":{"value":{"Literal":{"Str":""}},"ty":{"Ref":["Erased",{"Adt":[{"Builtin":"Str"},{"regions":[],"types":[],"const_generics":[],"trait_refs":[],"target":"Builtin"}]},"Shared"]}}},{"Const":{"value":{"Literal":{"Str":"\n"}},"ty":{"Ref":["Erased",{"Adt":[{"Builtin":"Str"},{"regions":[],"types":[],"const_generics":[],"trait_refs":[],"target":"Builtin"}]},"Shared"]}}}]]}]},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":7,"col":13},"end":{"line":7,"col":18}},"generated_from_span":null},"content":{"Assign":[{"kind":{"Base":12},"ty":{"Ref":["Erased",{"Adt":[{"Builtin":"Array"},{"regions":[],"types":[{"Ref":["Erased",{"Adt":[{"Builtin":"Str"},{"regions":[],"types":[],"const_generics":[],"trait_refs":[],"target":"Builtin"}]},"Shared"]}],"const_generics":[{"Value":{"Scalar":{"Usize":"2"}}}],"trait_refs":[],"target":"Builtin"}]},"Shared"]}},{"Ref":[{"kind":{"Base":13},"ty":{"Adt":[{"Builtin":"Array"},{"regions":[],"types":[{"Ref":["Erased",{"Adt":[{"Builtin":"Str"},{"regions":[],"types":[],"const_generics":[],"trait_refs":[],"target":"Builtin"}]},"Shared"]}],"const_generics":[{"Value":{"Scalar":{"Usize":"2"}}}],"trait_refs":[],"target":"Builtin"}]}},"Shared"]}]},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":7,"col":13},"end":{"line":7,"col":18}},"generated_from_span":null},"content":{"Assign":[{"kind":{"Base":11},"ty":{"Ref":["Erased",{"Adt":[{"Builtin":"Array"},{"regions":[],"types":[{"Ref":["Erased",{"Adt":[{"Builtin":"Str"},{"regions":[],"types":[],"const_generics":[],"trait_refs":[],"target":"Builtin"}]},"Shared"]}],"const_generics":[{"Value":{"Scalar":{"Usize":"2"}}}],"trait_refs":[],"target":"Builtin"}]},"Shared"]}},{"Ref":[{"kind":{"Projection":[{"kind":{"Base":12},"ty":{"Ref":["Erased",{"Adt":[{"Builtin":"Array"},{"regions":[],"types":[{"Ref":["Erased",{"Adt":[{"Builtin":"Str"},{"regions":[],"types":[],"const_generics":[],"trait_refs":[],"target":"Builtin"}]},"Shared"]}],"const_generics":[{"Value":{"Scalar":{"Usize":"2"}}}],"trait_refs":[],"target":"Builtin"}]},"Shared"]}},"Deref"]},"ty":{"Adt":[{"Builtin":"Array"},{"regions":[],"types":[{"Ref":["Erased",{"Adt":[{"Builtin":"Str"},{"regions":[],"types":[],"const_generics":[],"trait_refs":[],"target":"Builtin"}]},"Shared"]}],"const_generics":[{"Value":{"Scalar":{"Usize":"2"}}}],"trait_refs":[],"target":"Builtin"}]}},"Shared"]}]},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":7,"col":14},"end":{"line":7,"col":17}},"generated_from_span":null},"content":{"Assign":[{"kind":{"Base":19},"ty":{"Ref":["Erased",{"Adt":[{"Adt":0},{"regions":[],"types":[],"const_generics":[],"trait_refs":[],"target":{"Item":{"Type":0}}}]},"Shared"]}},{"Ref":[{"kind":{"Base":5},"ty":{"Adt":[{"Adt":0},{"regions":[],"types":[],"const_generics":[],"trait_refs":[],"target":{"Item":{"Type":0}}}]}},"Shared"]}]},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":7,"col":14},"end":{"line":7,"col":17}},"generated_from_span":null},"content":{"Assign":[{"kind":{"Base":18},"ty":{"Ref":["Erased",{"Adt":[{"Adt":0},{"regions":[],"types":[],"const_generics":[],"trait_refs":[],"target":{"Item":{"Type":0}}}]},"Shared"]}},{"Ref":[{"kind":{"Projection":[{"kind":{"Base":19},"ty":{"Ref":["Erased",{"Adt":[{"Adt":0},{"regions":[],"types":[],"const_generics":[],"trait_refs":[],"target":{"Item":{"Type":0}}}]},"Shared"]}},"Deref"]},"ty":{"Adt":[{"Adt":0},{"regions":[],"types":[],"const_generics":[],"trait_refs":[],"target":{"Item":{"Type":0}}}]}},"Shared"]}]},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":7,"col":14},"end":{"line":7,"col":17}},"generated_from_span":null},"content":{"Call":{"func":{"Regular":{"func":{"Fun":{"Regular":2}},"generics":{"regions":["Erased","Erased"],"types":[{"Adt":[{"Adt":0},{"regions":[],"types":[],"const_generics":[],"trait_refs":[],"target":{"Item":{"Type":0}}}]}],"const_generics":[],"trait_refs":[{"kind":{"BuiltinOrAuto":{"trait_decl_ref":{"regions":[],"skip_binder":{"trait_id":1,"generics":{"regions":[],"types":[{"Adt":[{"Adt":0},{"regions":[],"types":[],"const_generics":[],"trait_refs":[],"target":{"Item":{"Type":0}}}]}],"const_generics":[],"trait_refs":[],"target":{"Item":{"TraitDecl":1}}}}},"parent_trait_refs":[],"types":[]}},"trait_decl_ref":{"regions":[],"skip_binder":{"trait_id":1,"generics":{"regions":[],"types":[{"Adt":[{"Adt":0},{"regions":[],"types":[],"const_generics":[],"trait_refs":[],"target":{"Item":{"Type":0}}}]}],"const_generics":[],"trait_refs":[],"target":{"Item":{"TraitDecl":1}}}}}},{"kind":{"TraitImpl":[1,{"regions":[],"types":[],"const_generics":[],"trait_refs":[],"target":{"Item":{"TraitImpl":1}}}]},"trait_decl_ref":{"regions":[],"skip_binder":{"trait_id":2,"generics":{"regions":[],"types":[{"Adt":[{"Adt":0},{"regions":[],"types":[],"const_generics":[],"trait_refs":[],"target":{"Item":{"Type":0}}}]}],"const_generics":[],"trait_refs":[],"target":{"Item":{"TraitDecl":2}}}}}}],"target":{"Item":{"Fun":2}}}}},"args":[{"Move":{"kind":{"Base":18},"ty":{"Ref":["Erased",{"Adt":[{"Adt":0},{"regions":[],"types":[],"const_generics":[],"trait_refs":[],"target":{"Item":{"Type":0}}}]},"Shared"]}}}],"dest":{"kind":{"Base":17},"ty":{"Adt":[{"Adt":2},{"regions":["Erased"],"types":[],"const_generics":[],"trait_refs":[],"target":{"Item":{"Type":2}}}]}}}},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":7,"col":16},"end":{"line":7,"col":17}},"generated_from_span":null},"content":{"Drop":{"kind":{"Base":18},"ty":{"Ref":["Erased",{"Adt":[{"Adt":0},{"regions":[],"types":[],"const_generics":[],"trait_refs":[],"target":{"Item":{"Type":0}}}]},"Shared"]}}},"comments_before":[]},{"span":{"span":{"file_id":3,"beg":{"line":143,"col":27},"end":{"line":143,"col":60}},"generated_from_span":null},"content":{"Assign":[{"kind":{"Base":16},"ty":{"Adt":[{"Builtin":"Array"},{"regions":[],"types":[{"Adt":[{"Adt":2},{"regions":["Erased"],"types":[],"const_generics":[],"trait_refs":[],"target":{"Item":{"Type":2}}}]}],"const_generics":[{"Value":{"Scalar":{"Usize":"1"}}}],"trait_refs":[],"target":"Builtin"}]}},{"Aggregate":[{"Array":[{"Adt":[{"Adt":2},{"regions":["Erased"],"types":[],"const_generics":[],"trait_refs":[],"target":{"Item":{"Type":2}}}]},{"Value":{"Scalar":{"Usize":"1"}}}]},[{"Move":{"kind":{"Base":17},"ty":{"Adt":[{"Adt":2},{"regions":["Erased"],"types":[],"const_generics":[],"trait_refs":[],"target":{"Item":{"Type":2}}}]}}}]]}]},"comments_before":[]},{"span":{"span":{"file_id":3,"beg":{"line":143,"col":59},"end":{"line":143,"col":60}},"generated_from_span":null},"content":{"Drop":{"kind":{"Base":17},"ty":{"Adt":[{"Adt":2},{"regions":["Erased"],"types":[],"const_generics":[],"trait_refs":[],"target":{"Item":{"Type":2}}}]}}},"comments_before":[]},{"span":{"span":{"file_id":3,"beg":{"line":143,"col":27},"end":{"line":143,"col":60}},"generated_from_span":null},"content":{"Assign":[{"kind":{"Base":15},"ty":{"Ref":["Erased",{"Adt":[{"Builtin":"Array"},{"regions":[],"types":[{"Adt":[{"Adt":2},{"regions":["Erased"],"types":[],"const_generics":[],"trait_refs":[],"target":{"Item":{"Type":2}}}]}],"const_generics":[{"Value":{"Scalar":{"Usize":"1"}}}],"trait_refs":[],"target":"Builtin"}]},"Shared"]}},{"Ref":[{"kind":{"Base":16},"ty":{"Adt":[{"Builtin":"Array"},{"regions":[],"types":[{"Adt":[{"Adt":2},{"regions":["Erased"],"types":[],"const_generics":[],"trait_refs":[],"target":{"Item":{"Type":2}}}]}],"const_generics":[{"Value":{"Scalar":{"Usize":"1"}}}],"trait_refs":[],"target":"Builtin"}]}},"Shared"]}]},"comments_before":[]},{"span":{"span":{"file_id":3,"beg":{"line":143,"col":27},"end":{"line":143,"col":60}},"generated_from_span":null},"content":{"Assign":[{"kind":{"Base":14},"ty":{"Ref":["Erased",{"Adt":[{"Builtin":"Array"},{"regions":[],"types":[{"Adt":[{"Adt":2},{"regions":["Erased"],"types":[],"const_generics":[],"trait_refs":[],"target":{"Item":{"Type":2}}}]}],"const_generics":[{"Value":{"Scalar":{"Usize":"1"}}}],"trait_refs":[],"target":"Builtin"}]},"Shared"]}},{"Ref":[{"kind":{"Projection":[{"kind":{"Base":15},"ty":{"Ref":["Erased",{"Adt":[{"Builtin":"Array"},{"regions":[],"types":[{"Adt":[{"Adt":2},{"regions":["Erased"],"types":[],"const_generics":[],"trait_refs":[],"target":{"Item":{"Type":2}}}]}],"const_generics":[{"Value":{"Scalar":{"Usize":"1"}}}],"trait_refs":[],"target":"Builtin"}]},"Shared"]}},"Deref"]},"ty":{"Adt":[{"Builtin":"Array"},{"regions":[],"types":[{"Adt":[{"Adt":2},{"regions":["Erased"],"types":[],"const_generics":[],"trait_refs":[],"target":{"Item":{"Type":2}}}]}],"const_generics":[{"Value":{"Scalar":{"Usize":"1"}}}],"trait_refs":[],"target":"Builtin"}]}},"Shared"]}]},"comments_before":[]},{"span":{"span":{"file_id":3,"beg":{"line":143,"col":27},"end":{"line":143,"col":60}},"generated_from_span":null},"content":{"Call":{"func":{"Regular":{"func":{"Fun":{"Regular":3}},"generics":{"regions":["Erased"],"types":[],"const_generics":[{"Value":{"Scalar":{"Usize":"2"}}},{"Value":{"Scalar":{"Usize":"1"}}}],"trait_refs":[],"target":{"Item":{"Fun":3}}}}},"args":[{"Move":{"kind":{"Base":11},"ty":{"Ref":["Erased",{"Adt":[{"Builtin":"Array"},{"regions":[],"types":[{"Ref":["Erased",{"Adt":[{"Builtin":"Str"},{"regions":[],"types":[],"const_generics":[],"trait_refs":[],"target":"Builtin"}]},"Shared"]}],"const_generics":[{"Value":{"Scalar":{"Usize":"2"}}}],"trait_refs":[],"target":"Builtin"}]},"Shared"]}}},{"Move":{"kind":{"Base":14},"ty":{"Ref":["Erased",{"Adt":[{"Builtin":"Array"},{"regions":[],"types":[{"Adt":[{"Adt":2},{"regions":["Erased"],"types":[],"const_generics":[],"trait_refs":[],"target":{"Item":{"Type":2}}}]}],"const_generics":[{"Value":{"Scalar":{"Usize":"1"}}}],"trait_refs":[],"target":"Builtin"}]},"Shared"]}}}],"dest":{"kind":{"Base":10},"ty":{"Adt":[{"Adt":1},{"regions":["Erased"],"types":[],"const_generics":[],"trait_refs":[],"target":{"Item":{"Type":1}}}]}}}},"comments_before":[]},{"span":{"span":{"file_id":3,"beg":{"line":143,"col":59},"end":{"line":143,"col":60}},"generated_from_span":null},"content":{"Drop":{"kind":{"Base":14},"ty":{"Ref":["Erased",{"Adt":[{"Builtin":"Array"},{"regions":[],"types":[{"Adt":[{"Adt":2},{"regions":["Erased"],"types":[],"const_generics":[],"trait_refs":[],"target":{"Item":{"Type":2}}}]}],"const_generics":[{"Value":{"Scalar":{"Usize":"1"}}}],"trait_refs":[],"target":"Builtin"}]},"Shared"]}}},"comments_before":[]},{"span":{"span":{"file_id":3,"beg":{"line":143,"col":59},"end":{"line":143,"col":60}},"generated_from_span":null},"content":{"Drop":{"kind":{"Base":11},"ty":{"Ref":["Erased",{"Adt":[{"Builtin":"Array"},{"regions":[],"types":[{"Ref":["Erased",{"Adt":[{"Builtin":"Str"},{"regions":[],"types":[],"const_generics":[],"trait_refs":[],"target":"Builtin"}]},"Shared"]}],"const_generics":[{"Value":{"Scalar":{"Usize":"2"}}}],"trait_refs":[],"target":"Builtin"}]},"Shared"]}}},"comments_before":[]},{"span":{"span":{"file_id":3,"beg":{"line":143,"col":8},"end":{"line":143,"col":61}},"generated_from_span":null},"content":{"Call":{"func":{"Regular":{"func":{"Fun":{"Regular":4}},"generics":{"regions":["Erased"],"types":[],"const_generics":[],"trait_refs":[],"target":{"Item":{"Fun":4}}}}},"args":[{"Move":{"kind":{"Base":10},"ty":{"Adt":[{"Adt":1},{"regions":["Erased"],"types":[],"const_generics":[],"trait_refs":[],"target":{"Item":{"Type":1}}}]}}}],"dest":{"kind":{"Base":9},"ty":{"Adt":["Tuple",{"regions":[],"types":[],"const_generics":[],"trait_refs":[],"target":"Builtin"}]}}}},"comments_before":[]},{"span":{"span":{"file_id":3,"beg":{"line":143,"col":60},"end":{"line":143,"col":61}},"generated_from_span":null},"content":{"Drop":{"kind":{"Base":10},"ty":{"Adt":[{"Adt":1},{"regions":["Erased"],"types":[],"const_generics":[],"trait_refs":[],"target":{"Item":{"Type":1}}}]}}},"comments_before":[]},{"span":{"span":{"file_id":3,"beg":{"line":143,"col":61},"end":{"line":143,"col":62}},"generated_from_span":null},"content":{"Drop":{"kind":{"Base":19},"ty":{"Ref":["Erased",{"Adt":[{"Adt":0},{"regions":[],"types":[],"const_generics":[],"trait_refs":[],"target":{"Item":{"Type":0}}}]},"Shared"]}}},"comments_before":[]},{"span":{"span":{"file_id":3,"beg":{"line":143,"col":61},"end":{"line":143,"col":62}},"generated_from_span":null},"content":{"Drop":{"kind":{"Base":16},"ty":{"Adt":[{"Builtin":"Array"},{"regions":[],"types":[{"Adt":[{"Adt":2},{"regions":["Erased"],"types":[],"const_generics":[],"trait_refs":[],"target":{"Item":{"Type":2}}}]}],"const_generics":[{"Value":{"Scalar":{"Usize":"1"}}}],"trait_refs":[],"target":"Builtin"}]}}},"comments_before":[]},{"span":{"span":{"file_id":3,"beg":{"line":143,"col":61},"end":{"line":143,"col":62}},"generated_from_span":null},"content":{"Drop":{"kind":{"Base":15},"ty":{"Ref":["Erased",{"Adt":[{"Builtin":"Array"},{"regions":[],"types":[{"Adt":[{"Adt":2},{"regions":["Erased"],"types":[],"const_generics":[],"trait_refs":[],"target":{"Item":{"Type":2}}}]}],"const_generics":[{"Value":{"Scalar":{"Usize":"1"}}}],"trait_refs":[],"target":"Builtin"}]},"Shared"]}}},"comments_before":[]},{"span":{"span":{"file_id":3,"beg":{"line":143,"col":61},"end":{"line":143,"col":62}},"generated_from_span":null},"content":{"Drop":{"kind":{"Base":13},"ty":{"Adt":[{"Builtin":"Array"},{"regions":[],"types":[{"Ref":["Erased",{"Adt":[{"Builtin":"Str"},{"regions":[],"types":[],"const_generics":[],"trait_refs":[],"target":"Builtin"}]},"Shared"]}],"const_generics":[{"Value":{"Scalar":{"Usize":"2"}}}],"trait_refs":[],"target":"Builtin"}]}}},"comments_before":[]},{"span":{"span":{"file_id":3,"beg":{"line":143,"col":61},"end":{"line":143,"col":62}},"generated_from_span":null},"content":{"Drop":{"kind":{"Base":12},"ty":{"Ref":["Erased",{"Adt":[{"Builtin":"Array"},{"regions":[],"types":[{"Ref":["Erased",{"Adt":[{"Builtin":"Str"},{"regions":[],"types":[],"const_generics":[],"trait_refs":[],"target":"Builtin"}]},"Shared"]}],"const_generics":[{"Value":{"Scalar":{"Usize":"2"}}}],"trait_refs":[],"target":"Builtin"}]},"Shared"]}}},"comments_before":[]},{"span":{"span":{"file_id":3,"beg":{"line":143,"col":61},"end":{"line":143,"col":62}},"generated_from_span":null},"content":{"Drop":{"kind":{"Base":9},"ty":{"Adt":["Tuple",{"regions":[],"types":[],"const_generics":[],"trait_refs":[],"target":"Builtin"}]}}},"comments_before":[]},{"span":{"span":{"file_id":3,"beg":{"line":144,"col":4},"end":{"line":144,"col":5}},"generated_from_span":null},"content":{"Drop":{"kind":{"Base":8},"ty":{"Adt":["Tuple",{"regions":[],"types":[],"const_generics":[],"trait_refs":[],"target":"Builtin"}]}}},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":1,"col":10},"end":{"line":8,"col":1}},"generated_from_span":null},"content":{"Assign":[{"kind":{"Base":0},"ty":{"Adt":["Tuple",{"regions":[],"types":[],"const_generics":[],"trait_refs":[],"target":"Builtin"}]}},{"Aggregate":[{"Adt":["Tuple",null,null,{"regions":[],"types":[],"const_generics":[],"trait_refs":[],"target":"Builtin"}]},[]]}]},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":8,"col":0},"end":{"line":8,"col":1}},"generated_from_span":null},"content":{"Drop":{"kind":{"Base":5},"ty":{"Adt":[{"Adt":0},{"regions":[],"types":[],"const_generics":[],"trait_refs":[],"target":{"Item":{"Type":0}}}]}}},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":8,"col":0},"end":{"line":8,"col":1}},"generated_from_span":null},"content":{"Drop":{"kind":{"Base":5},"ty":{"Adt":[{"Adt":0},{"regions":[],"types":[],"const_generics":[],"trait_refs":[],"target":{"Item":{"Type":0}}}]}}},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":8,"col":0},"end":{"line":8,"col":1}},"generated_from_span":null},"content":{"Drop":{"kind":{"Base":3},"ty":{"RawPtr":[{"Adt":[{"Adt":0},{"regions":[],"types":[],"const_generics":[],"trait_refs":[],"target":{"Item":{"Type":0}}}]},"Mut"]}}},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":8,"col":0},"end":{"line":8,"col":1}},"generated_from_span":null},"content":{"Drop":{"kind":{"Base":2},"ty":{"Ref":["Erased",{"Adt":[{"Adt":0},{"regions":[],"types":[],"const_generics":[],"trait_refs":[],"target":{"Item":{"Type":0}}}]},"Mut"]}}},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":8,"col":0},"end":{"line":8,"col":1}},"generated_from_span":null},"content":{"Drop":{"kind":{"Base":1},"ty":{"Adt":[{"Adt":0},{"regions":[],"types":[],"const_generics":[],"trait_refs":[],"target":{"Item":{"Type":0}}}]}}},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":8,"col":0},"end":{"line":8,"col":1}},"generated_from_span":null},"content":{"Drop":{"kind":{"Base":1},"ty":{"Adt":[{"Adt":0},{"regions":[],"types":[],"const_generics":[],"trait_refs":[],"target":{"Item":{"Type":0}}}]}}},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":8,"col":1},"end":{"line":8,"col":1}},"generated_from_span":null},"content":{"Assign":[{"kind":{"Base":0},"ty":{"Adt":["Tuple",{"regions":[],"types":[],"const_generics":[],"trait_refs":[],"target":"Builtin"}]}},{"Aggregate":[{"Adt":["Tuple",null,null,{"regions":[],"types":[],"const_generics":[],"trait_refs":[],"target":"Builtin"}]},[]]}]},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":8,"col":1},"end":{"line":8,"col":1}},"generated_from_span":null},"content":"Return","comments_before":[]}]}}}}},{"def_id":1,"item_meta":{"name":[{"Ident":["core",0]},{"Ident":["convert",0]},{"Ident":["From",0]},{"Ident":["from",0]}],"span":{"span":{"file_id":7,"beg":{"line":585,"col":4},"end":{"line":585,"col":30}},"generated_from_span":null},"source_text":null,"attr_info":{"attributes":[{"DocComment":" Converts to this type from the input type."},{"Unknown":{"path":"rustc_diagnostic_item","args":null}},{"Unknown":{"path":"must_use","args":null}}],"inline":null,"rename":null,"public":true},"is_local":false,"opacity":"Foreign","lang_item":"from_fn"},"signature":{"is_unsafe":false,"is_closure":false,"closure_info":null,"generics":{"regions":[],"types":[{"index":0,"name":"Self"},{"index":1,"name":"T"}],"const_generics":[],"trait_clauses":[],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"inputs":[{"TypeVar":{"Free":1}}],"output":{"TypeVar":{"Free":0}}},"kind":{"TraitDecl":{"trait_ref":{"trait_id":0,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}},{"TypeVar":{"Free":1}}],"const_generics":[],"trait_refs":[],"target":{"Item":{"TraitDecl":0}}}},"item_name":"from","has_default":false}},"is_global_initializer":null,"body":{"Err":null}},{"def_id":2,"item_meta":{"name":[{"Ident":["core",0]},{"Ident":["fmt",0]},{"Ident":["rt",0]},{"Impl":[{"Ty":{"params":{"regions":[{"index":0,"name":null}],"types":[],"const_generics":[],"trait_clauses":[],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"skip_binder":{"Adt":[{"Adt":2},{"regions":[{"Var":{"Bound":[0,0]}}],"types":[],"const_generics":[],"trait_refs":[],"target":{"Item":{"Type":2}}}]},"kind":"InherentImplBlock"}},1]},{"Ident":["new_display",0]}],"span":{"span":{"file_id":6,"beg":{"line":113,"col":4},"end":{"line":113,"col":57}},"generated_from_span":null},"source_text":null,"attr_info":{"attributes":[],"inline":"Always","rename":null,"public":true},"is_local":false,"opacity":"Foreign","lang_item":null},"signature":{"is_unsafe":false,"is_closure":false,"closure_info":null,"generics":{"regions":[{"index":0,"name":null},{"index":1,"name":null}],"types":[{"index":0,"name":"T"}],"const_generics":[],"trait_clauses":[{"clause_id":0,"span":{"span":{"file_id":6,"beg":{"line":113,"col":23},"end":{"line":113,"col":24}},"generated_from_span":null},"origin":"WhereClauseOnFn","trait_":{"regions":[],"skip_binder":{"trait_id":1,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}}],"const_generics":[],"trait_refs":[],"target":{"Item":{"TraitDecl":1}}}}}},{"clause_id":1,"span":{"span":{"file_id":6,"beg":{"line":113,"col":26},"end":{"line":113,"col":33}},"generated_from_span":null},"origin":"WhereClauseOnFn","trait_":{"regions":[],"skip_binder":{"trait_id":2,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}}],"const_generics":[],"trait_refs":[],"target":{"Item":{"TraitDecl":2}}}}}}],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"inputs":[{"Ref":[{"Var":{"Free":1}},{"TypeVar":{"Free":0}},"Shared"]}],"output":{"Adt":[{"Adt":2},{"regions":[{"Var":{"Free":1}}],"types":[],"const_generics":[],"trait_refs":[],"target":{"Item":{"Type":2}}}]}},"kind":"Regular","is_global_initializer":null,"body":{"Err":null}},{"def_id":3,"item_meta":{"name":[{"Ident":["core",0]},{"Ident":["fmt",0]},{"Impl":[{"Ty":{"params":{"regions":[{"index":0,"name":"'a"}],"types":[],"const_generics":[],"trait_clauses":[],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"skip_binder":{"Adt":[{"Adt":1},{"regions":[{"Var":{"Bound":[0,0]}}],"types":[],"const_generics":[],"trait_refs":[],"target":{"Item":{"Type":1}}}]},"kind":"InherentImplBlock"}},2]},{"Ident":["new_v1",0]}],"span":{"span":{"file_id":4,"beg":{"line":345,"col":4},"end":{"line":348,"col":22}},"generated_from_span":null},"source_text":null,"attr_info":{"attributes":[{"DocComment":" When using the format_args!() macro, this function is used to generate the"},{"DocComment":" Arguments structure."}],"inline":"Hint","rename":null,"public":true},"is_local":false,"opacity":"Foreign","lang_item":null},"signature":{"is_unsafe":false,"is_closure":false,"closure_info":null,"generics":{"regions":[{"index":0,"name":"'a"}],"types":[],"const_generics":[{"index":0,"name":"P","ty":{"Integer":"Usize"}},{"index":1,"name":"A","ty":{"Integer":"Usize"}}],"trait_clauses":[],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"inputs":[{"Ref":[{"Var":{"Free":0}},{"Adt":[{"Builtin":"Array"},{"regions":[],"types":[{"Ref":["Static",{"Adt":[{"Builtin":"Str"},{"regions":[],"types":[],"const_generics":[],"trait_refs":[],"target":"Builtin"}]},"Shared"]}],"const_generics":[{"Var":{"Free":0}}],"trait_refs":[],"target":"Builtin"}]},"Shared"]},{"Ref":[{"Var":{"Free":0}},{"Adt":[{"Builtin":"Array"},{"regions":[],"types":[{"Adt":[{"Adt":2},{"regions":[{"Var":{"Free":0}}],"types":[],"const_generics":[],"trait_refs":[],"target":{"Item":{"Type":2}}}]}],"const_generics":[{"Var":{"Free":1}}],"trait_refs":[],"target":"Builtin"}]},"Shared"]}],"output":{"Adt":[{"Adt":1},{"regions":[{"Var":{"Free":0}}],"types":[],"const_generics":[],"trait_refs":[],"target":{"Item":{"Type":1}}}]}},"kind":"Regular","is_global_initializer":null,"body":{"Err":null}},{"def_id":4,"item_meta":{"name":[{"Ident":["std",0]},{"Ident":["io",0]},{"Ident":["stdio",0]},{"Ident":["_print",0]}],"span":{"span":{"file_id":9,"beg":{"line":1231,"col":0},"end":{"line":1231,"col":39}},"generated_from_span":null},"source_text":null,"attr_info":{"attributes":[{"Unknown":{"path":"unstable","args":"feature = \"print_internals\", reason =\n\"implementation detail which may disappear or be replaced at any time\", issue\n= \"none\""}},{"Unknown":{"path":"doc","args":"hidden"}},{"Unknown":{"path":"cfg","args":"not(test)"}}],"inline":null,"rename":null,"public":true},"is_local":false,"opacity":"Foreign","lang_item":null},"signature":{"is_unsafe":false,"is_closure":false,"closure_info":null,"generics":{"regions":[{"index":0,"name":null}],"types":[],"const_generics":[],"trait_clauses":[],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"inputs":[{"Adt":[{"Adt":1},{"regions":[{"Var":{"Free":0}}],"types":[],"const_generics":[],"trait_refs":[],"target":{"Item":{"Type":1}}}]}],"output":{"Adt":["Tuple",{"regions":[],"types":[],"const_generics":[],"trait_refs":[],"target":"Builtin"}]}},"kind":"Regular","is_global_initializer":null,"body":{"Err":null}},{"def_id":5,"item_meta":{"name":[{"Ident":["core",0]},{"Ident":["fmt",0]},{"Ident":["Display",0]},{"Ident":["fmt",0]}],"span":{"span":{"file_id":4,"beg":{"line":749,"col":4},"end":{"line":749,"col":51}},"generated_from_span":null},"source_text":null,"attr_info":{"attributes":[{"Unknown":{"path":"doc","args":null}},{"DocComment":""},{"DocComment":" # Examples"},{"DocComment":""},{"DocComment":" ```"},{"DocComment":" use std::fmt;"},{"DocComment":""},{"DocComment":" struct Position {"},{"DocComment":"     longitude: f32,"},{"DocComment":"     latitude: f32,"},{"DocComment":" }"},{"DocComment":""},{"DocComment":" impl fmt::Display for Position {"},{"DocComment":"     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {"},{"DocComment":"         write!(f, \"({}, {})\", self.longitude, self.latitude)"},{"DocComment":"     }"},{"DocComment":" }"},{"DocComment":""},{"DocComment":" assert_eq!("},{"DocComment":"     \"(1.987, 2.983)\","},{"DocComment":"     format!(\"{}\", Position { longitude: 1.987, latitude: 2.983, }),"},{"DocComment":" );"},{"DocComment":" ```"}],"inline":null,"rename":null,"public":true},"is_local":false,"opacity":"Foreign","lang_item":null},"signature":{"is_unsafe":false,"is_closure":false,"closure_info":null,"generics":{"regions":[{"index":0,"name":null},{"index":1,"name":null},{"index":2,"name":null}],"types":[{"index":0,"name":"Self"}],"const_generics":[],"trait_clauses":[],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"inputs":[{"Ref":[{"Var":{"Free":0}},{"TypeVar":{"Free":0}},"Shared"]},{"Ref":[{"Var":{"Free":1}},{"Adt":[{"Adt":3},{"regions":[{"Var":{"Free":2}}],"types":[],"const_generics":[],"trait_refs":[],"target":{"Item":{"Type":3}}}]},"Mut"]}],"output":{"Adt":[{"Adt":4},{"regions":[],"types":[{"Adt":["Tuple",{"regions":[],"types":[],"const_generics":[],"trait_refs":[],"target":"Builtin"}]},{"Adt":[{"Adt":5},{"regions":[],"types":[],"const_generics":[],"trait_refs":[],"target":{"Item":{"Type":5}}}]}],"const_generics":[],"trait_refs":[{"kind":{"BuiltinOrAuto":{"trait_decl_ref":{"regions":[],"skip_binder":{"trait_id":1,"generics":{"regions":[],"types":[{"Adt":["Tuple",{"regions":[],"types":[],"const_generics":[],"trait_refs":[],"target":"Builtin"}]}],"const_generics":[],"trait_refs":[],"target":{"Item":{"TraitDecl":1}}}}},"parent_trait_refs":[],"types":[]}},"trait_decl_ref":{"regions":[],"skip_binder":{"trait_id":1,"generics":{"regions":[],"types":[{"Adt":["Tuple",{"regions":[],"types":[],"const_generics":[],"trait_refs":[],"target":"Builtin"}]}],"const_generics":[],"trait_refs":[],"target":{"Item":{"TraitDecl":1}}}}}},{"kind":{"BuiltinOrAuto":{"trait_decl_ref":{"regions":[],"skip_binder":{"trait_id":1,"generics":{"regions":[],"types":[{"Adt":[{"Adt":5},{"regions":[],"types":[],"const_generics":[],"trait_refs":[],"target":{"Item":{"Type":5}}}]}],"const_generics":[],"trait_refs":[],"target":{"Item":{"TraitDecl":1}}}}},"parent_trait_refs":[],"types":[]}},"trait_decl_ref":{"regions":[],"skip_binder":{"trait_id":1,"generics":{"regions":[],"types":[{"Adt":[{"Adt":5},{"regions":[],"types":[],"const_generics":[],"trait_refs":[],"target":{"Item":{"Type":5}}}]}],"const_generics":[],"trait_refs":[],"target":{"Item":{"TraitDecl":1}}}}}}],"target":{"Item":{"Type":4}}}]}},"kind":{"TraitDecl":{"trait_ref":{"trait_id":2,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}}],"const_generics":[],"trait_refs":[],"target":{"Item":{"TraitDecl":2}}}},"item_name":"fmt","has_default":false}},"is_global_initializer":null,"body":{"Err":null}},{"def_id":6,"item_meta":{"name":[{"Ident":["alloc",0]},{"Ident":["string",0]},{"Impl":[{"Trait":1},21]},{"Ident":["fmt",0]}],"span":{"span":{"file_id":1,"beg":{"line":2497,"col":4},"end":{"line":2497,"col":60}},"generated_from_span":null},"source_text":null,"attr_info":{"attributes":[],"inline":"Hint","rename":null,"public":true},"is_local":false,"opacity":"Foreign","lang_item":null},"signature":{"is_unsafe":false,"is_closure":false,"closure_info":null,"generics":{"regions":[{"index":0,"name":null},{"index":1,"name":null},{"index":2,"name":null}],"types":[],"const_generics":[],"trait_clauses":[],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"inputs":[{"Ref":[{"Var":{"Free":0}},{"Adt":[{"Adt":0},{"regions":[],"types":[],"const_generics":[],"trait_refs":[],"target":{"Item":{"Type":0}}}]},"Shared"]},{"Ref":[{"Var":{"Free":1}},{"Adt":[{"Adt":3},{"regions":[{"Var":{"Free":2}}],"types":[],"const_generics":[],"trait_refs":[],"target":{"Item":{"Type":3}}}]},"Mut"]}],"output":{"Adt":[{"Adt":4},{"regions":[],"types":[{"Adt":["Tuple",{"regions":[],"types":[],"const_generics":[],"trait_refs":[],"target":"Builtin"}]},{"Adt":[{"Adt":5},{"regions":[],"types":[],"const_generics":[],"trait_refs":[],"target":{"Item":{"Type":5}}}]}],"const_generics":[],"trait_refs":[{"kind":{"BuiltinOrAuto":{"trait_decl_ref":{"regions":[],"skip_binder":{"trait_id":1,"generics":{"regions":[],"types":[{"Adt":["Tuple",{"regions":[],"types":[],"const_generics":[],"trait_refs":[],"target":"Builtin"}]}],"const_generics":[],"trait_refs":[],"target":{"Item":{"TraitDecl":1}}}}},"parent_trait_refs":[],"types":[]}},"trait_decl_ref":{"regions":[],"skip_binder":{"trait_id":1,"generics":{"regions":[],"types":[{"Adt":["Tuple",{"regions":[],"types":[],"const_generics":[],"trait_refs":[],"target":"Builtin"}]}],"const_generics":[],"trait_refs":[],"target":{"Item":{"TraitDecl":1}}}}}},{"kind":{"BuiltinOrAuto":{"trait_decl_ref":{"regions":[],"skip_binder":{"trait_id":1,"generics":{"regions":[],"types":[{"Adt":[{"Adt":5},{"regions":[],"types":[],"const_generics":[],"trait_refs":[],"target":{"Item":{"Type":5}}}]}],"const_generics":[],"trait_refs":[],"target":{"Item":{"TraitDecl":1}}}}},"parent_trait_refs":[],"types":[]}},"trait_decl_ref":{"regions":[],"skip_binder":{"trait_id":1,"generics":{"regions":[],"types":[{"Adt":[{"Adt":5},{"regions":[],"types":[],"const_generics":[],"trait_refs":[],"target":{"Item":{"Type":5}}}]}],"const_generics":[],"trait_refs":[],"target":{"Item":{"TraitDecl":1}}}}}}],"target":{"Item":{"Type":4}}}]}},"kind":{"TraitImpl":{"impl_ref":{"impl_id":1,"generics":{"regions":[],"types":[],"const_generics":[],"trait_refs":[],"target":{"Item":{"TraitImpl":1}}}},"trait_ref":{"trait_id":2,"generics":{"regions":[],"types":[{"Adt":[{"Adt":0},{"regions":[],"types":[],"const_generics":[],"trait_refs":[],"target":{"Item":{"Type":0}}}]}],"const_generics":[],"trait_refs":[],"target":{"Item":{"TraitDecl":2}}}},"item_name":"fmt","reuses_default":true}},"is_global_initializer":null,"body":{"Err":null}},{"def_id":7,"item_meta":{"name":[{"Ident":["alloc",0]},{"Ident":["string",0]},{"Impl":[{"Trait":0},44]},{"Ident":["from",0]}],"span":{"span":{"file_id":1,"beg":{"line":2879,"col":4},"end":{"line":2879,"col":30}},"generated_from_span":null},"source_text":null,"attr_info":{"attributes":[{"DocComment":" Converts a `&str` into a [`String`]."},{"DocComment":""},{"DocComment":" The result is allocated on the heap."}],"inline":"Hint","rename":null,"public":true},"is_local":false,"opacity":"Foreign","lang_item":null},"signature":{"is_unsafe":false,"is_closure":false,"closure_info":null,"generics":{"regions":[{"index":0,"name":null}],"types":[],"const_generics":[],"trait_clauses":[],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"inputs":[{"Ref":[{"Var":{"Free":0}},{"Adt":[{"Builtin":"Str"},{"regions":[],"types":[],"const_generics":[],"trait_refs":[],"target":"Builtin"}]},"Shared"]}],"output":{"Adt":[{"Adt":0},{"regions":[],"types":[],"const_generics":[],"trait_refs":[],"target":{"Item":{"Type":0}}}]}},"kind":{"TraitImpl":{"impl_ref":{"impl_id":0,"generics":{"regions":[{"Var":{"Free":0}}],"types":[],"const_generics":[],"trait_refs":[],"target":{"Item":{"TraitImpl":0}}}},"trait_ref":{"trait_id":0,"generics":{"regions":[],"types":[{"Adt":[{"Adt":0},{"regions":[],"types":[],"const_generics":[],"trait_refs":[],"target":{"Item":{"Type":0}}}]},{"Ref":[{"Var":{"Free":0}},{"Adt":[{"Builtin":"Str"},{"regions":[],"types":[],"const_generics":[],"trait_refs":[],"target":"Builtin"}]},"Shared"]}],"const_generics":[],"trait_refs":[],"target":{"Item":{"TraitDecl":0}}}},"item_name":"from","reuses_default":true}},"is_global_initializer":null,"body":{"Err":null}}],"global_decls":[],"trait_decls":[{"def_id":0,"item_meta":{"name":[{"Ident":["core",0]},{"Ident":["convert",0]},{"Ident":["From",0]}],"span":{"span":{"file_id":7,"beg":{"line":580,"col":0},"end":{"line":580,"col":24}},"generated_from_span":null},"source_text":null,"attr_info":{"attributes":[{"DocComment":" Used to do value-to-value conversions while consuming the input value. It is the reciprocal of"},{"DocComment":" [`Into`]."},{"DocComment":""},{"DocComment":" One should always prefer implementing `From` over [`Into`]"},{"DocComment":" because implementing `From` automatically provides one with an implementation of [`Into`]"},{"DocComment":" thanks to the blanket implementation in the standard library."},{"DocComment":""},{"DocComment":" Only implement [`Into`] when targeting a version prior to Rust 1.41 and converting to a type"},{"DocComment":" outside the current crate."},{"DocComment":" `From` was not able to do these types of conversions in earlier versions because of Rust's"},{"DocComment":" orphaning rules."},{"DocComment":" See [`Into`] for more details."},{"DocComment":""},{"DocComment":" Prefer using [`Into`] over using `From` when specifying trait bounds on a generic function."},{"DocComment":" This way, types that directly implement [`Into`] can be used as arguments as well."},{"DocComment":""},{"DocComment":" The `From` trait is also very useful when performing error handling. When constructing a function"},{"DocComment":" that is capable of failing, the return type will generally be of the form `Result<T, E>`."},{"DocComment":" `From` simplifies error handling by allowing a function to return a single error type"},{"DocComment":" that encapsulates multiple error types. See the \"Examples\" section and [the book][book] for more"},{"DocComment":" details."},{"DocComment":""},{"DocComment":" **Note: This trait must not fail**. The `From` trait is intended for perfect conversions."},{"DocComment":" If the conversion can fail or is not perfect, use [`TryFrom`]."},{"DocComment":""},{"DocComment":" # Generic Implementations"},{"DocComment":""},{"DocComment":" - `From<T> for U` implies [`Into`]`<U> for T`"},{"DocComment":" - `From` is reflexive, which means that `From<T> for T` is implemented"},{"DocComment":""},{"DocComment":" # When to implement `From`"},{"DocComment":""},{"DocComment":" While there's no technical restrictions on which conversions can be done using"},{"DocComment":" a `From` implementation, the general expectation is that the conversions"},{"DocComment":" should typically be restricted as follows:"},{"DocComment":""},{"DocComment":" * The conversion is *infallible*: if the conversion can fail, use [`TryFrom`]"},{"DocComment":"   instead; don't provide a `From` impl that panics."},{"DocComment":""},{"DocComment":" * The conversion is *lossless*: semantically, it should not lose or discard"},{"DocComment":"   information. For example, `i32: From<u16>` exists, where the original"},{"DocComment":"   value can be recovered using `u16: TryFrom<i32>`.  And `String: From<&str>`"},{"DocComment":"   exists, where you can get something equivalent to the original value via"},{"DocComment":"   `Deref`.  But `From` cannot be used to convert from `u32` to `u16`, since"},{"DocComment":"   that cannot succeed in a lossless way.  (There's some wiggle room here for"},{"DocComment":"   information not considered semantically relevant.  For example,"},{"DocComment":"   `Box<[T]>: From<Vec<T>>` exists even though it might not preserve capacity,"},{"DocComment":"   like how two vectors can be equal despite differing capacities.)"},{"DocComment":""},{"DocComment":" * The conversion is *value-preserving*: the conceptual kind and meaning of"},{"DocComment":"   the resulting value is the same, even though the Rust type and technical"},{"DocComment":"   representation might be different.  For example `-1_i8 as u8` is *lossless*,"},{"DocComment":"   since `as` casting back can recover the original value, but that conversion"},{"DocComment":"   is *not* available via `From` because `-1` and `255` are different conceptual"},{"DocComment":"   values (despite being identical bit patterns technically).  But"},{"DocComment":"   `f32: From<i16>` *is* available because `1_i16` and `1.0_f32` are conceptually"},{"DocComment":"   the same real number (despite having very different bit patterns technically)."},{"DocComment":"   `String: From<char>` is available because they're both *text*, but"},{"DocComment":"   `String: From<u32>` is *not* available, since `1` (a number) and `\"1\"`"},{"DocComment":"   (text) are too different.  (Converting values to text is instead covered"},{"DocComment":"   by the [`Display`](crate::fmt::Display) trait.)"},{"DocComment":""},{"DocComment":" * The conversion is *obvious*: it's the only reasonable conversion between"},{"DocComment":"   the two types.  Otherwise it's better to have it be a named method or"},{"DocComment":"   constructor, like how [`str::as_bytes`] is a method and how integers have"},{"DocComment":"   methods like [`u32::from_ne_bytes`], [`u32::from_le_bytes`], and"},{"DocComment":"   [`u32::from_be_bytes`], none of which are `From` implementations.  Whereas"},{"DocComment":"   there's only one reasonable way to wrap an [`Ipv6Addr`](crate::net::Ipv6Addr)"},{"DocComment":"   into an [`IpAddr`](crate::net::IpAddr), thus `IpAddr: From<Ipv6Addr>` exists."},{"DocComment":""},{"DocComment":" # Examples"},{"DocComment":""},{"DocComment":" [`String`] implements `From<&str>`:"},{"DocComment":""},{"DocComment":" An explicit conversion from a `&str` to a String is done as follows:"},{"DocComment":""},{"DocComment":" ```"},{"DocComment":" let string = \"hello\".to_string();"},{"DocComment":" let other_string = String::from(\"hello\");"},{"DocComment":""},{"DocComment":" assert_eq!(string, other_string);"},{"DocComment":" ```"},{"DocComment":""},{"DocComment":" While performing error handling it is often useful to implement `From` for your own error type."},{"DocComment":" By converting underlying error types to our own custom error type that encapsulates the"},{"DocComment":" underlying error type, we can return a single error type without losing information on the"},{"DocComment":" underlying cause. The '?' operator automatically converts the underlying error type to our"},{"DocComment":" custom error type with `From::from`."},{"DocComment":""},{"DocComment":" ```"},{"DocComment":" use std::fs;"},{"DocComment":" use std::io;"},{"DocComment":" use std::num;"},{"DocComment":""},{"DocComment":" enum CliError {"},{"DocComment":"     IoError(io::Error),"},{"DocComment":"     ParseError(num::ParseIntError),"},{"DocComment":" }"},{"DocComment":""},{"DocComment":" impl From<io::Error> for CliError {"},{"DocComment":"     fn from(error: io::Error) -> Self {"},{"DocComment":"         CliError::IoError(error)"},{"DocComment":"     }"},{"DocComment":" }"},{"DocComment":""},{"DocComment":" impl From<num::ParseIntError> for CliError {"},{"DocComment":"     fn from(error: num::ParseIntError) -> Self {"},{"DocComment":"         CliError::ParseError(error)"},{"DocComment":"     }"},{"DocComment":" }"},{"DocComment":""},{"DocComment":" fn open_and_parse_file(file_name: &str) -> Result<i32, CliError> {"},{"DocComment":"     let mut contents = fs::read_to_string(&file_name)?;"},{"DocComment":"     let num: i32 = contents.trim().parse()?;"},{"DocComment":"     Ok(num)"},{"DocComment":" }"},{"DocComment":" ```"},{"DocComment":""},{"DocComment":" [`String`]: ../../std/string/struct.String.html"},{"DocComment":" [`from`]: From::from"},{"DocComment":" [book]: ../../book/ch09-00-error-handling.html"},{"Unknown":{"path":"rustc_diagnostic_item","args":null}},{"Unknown":{"path":"rustc_on_unimplemented","args":"on(all(_Self = \"&str\", T = \"alloc::string::String\"), note =\n\"to coerce a `{T}` into a `{Self}`, use `&*` as a prefix\",)"}}],"inline":null,"rename":null,"public":true},"is_local":false,"opacity":"Foreign","lang_item":"From"},"generics":{"regions":[],"types":[{"index":0,"name":"Self"},{"index":1,"name":"T"}],"const_generics":[],"trait_clauses":[],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"parent_clauses":[{"clause_id":0,"span":{"span":{"file_id":7,"beg":{"line":580,"col":19},"end":{"line":580,"col":24}},"generated_from_span":null},"origin":"WhereClauseOnTrait","trait_":{"regions":[],"skip_binder":{"trait_id":1,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}}],"const_generics":[],"trait_refs":[],"target":{"Item":{"TraitDecl":1}}}}}},{"clause_id":1,"span":{"span":{"file_id":7,"beg":{"line":580,"col":15},"end":{"line":580,"col":16}},"generated_from_span":null},"origin":"WhereClauseOnTrait","trait_":{"regions":[],"skip_binder":{"trait_id":1,"generics":{"regions":[],"types":[{"TypeVar":{"Free":1}}],"const_generics":[],"trait_refs":[],"target":{"Item":{"TraitDecl":1}}}}}}],"consts":[],"const_defaults":{},"types":[],"type_defaults":{},"type_clauses":[],"methods":[["from",{"params":{"regions":[],"types":[],"const_generics":[],"trait_clauses":[],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"skip_binder":{"id":1,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}},{"TypeVar":{"Free":1}}],"const_generics":[],"trait_refs":[],"target":{"Item":{"Fun":1}}}},"kind":{"TraitMethod":[0,"from"]}}]]},{"def_id":1,"item_meta":{"name":[{"Ident":["core",0]},{"Ident":["marker",0]},{"Ident":["Sized",0]}],"span":{"span":{"file_id":8,"beg":{"line":146,"col":0},"end":{"line":146,"col":15}},"generated_from_span":null},"source_text":null,"attr_info":{"attributes":[{"DocComment":" Types with a constant size known at compile time."},{"DocComment":""},{"DocComment":" All type parameters have an implicit bound of `Sized`. The special syntax"},{"DocComment":" `?Sized` can be used to remove this bound if it's not appropriate."},{"DocComment":""},{"DocComment":" ```"},{"DocComment":" # #![allow(dead_code)]"},{"DocComment":" struct Foo<T>(T);"},{"DocComment":" struct Bar<T: ?Sized>(T);"},{"DocComment":""},{"DocComment":" // struct FooUse(Foo<[i32]>); // error: Sized is not implemented for [i32]"},{"DocComment":" struct BarUse(Bar<[i32]>); // OK"},{"DocComment":" ```"},{"DocComment":""},{"DocComment":" The one exception is the implicit `Self` type of a trait. A trait does not"},{"DocComment":" have an implicit `Sized` bound as this is incompatible with [trait object]s"},{"DocComment":" where, by definition, the trait needs to work with all possible implementors,"},{"DocComment":" and thus could be any size."},{"DocComment":""},{"DocComment":" Although Rust will let you bind `Sized` to a trait, you won't"},{"DocComment":" be able to use it to form a trait object later:"},{"DocComment":""},{"DocComment":" ```"},{"DocComment":" # #![allow(unused_variables)]"},{"DocComment":" trait Foo { }"},{"DocComment":" trait Bar: Sized { }"},{"DocComment":""},{"DocComment":" struct Impl;"},{"DocComment":" impl Foo for Impl { }"},{"DocComment":" impl Bar for Impl { }"},{"DocComment":""},{"DocComment":" let x: &dyn Foo = &Impl;    // OK"},{"DocComment":" // let y: &dyn Bar = &Impl; // error: the trait `Bar` cannot"},{"DocComment":"                             // be made into an object"},{"DocComment":" ```"},{"DocComment":""},{"DocComment":" [trait object]: ../../book/ch17-02-trait-objects.html"},{"Unknown":{"path":"doc","args":"alias = \"?\", alias = \"?Sized\""}},{"Unknown":{"path":"diagnostic::on_unimplemented","args":"message =\n\"the size for values of type `{Self}` cannot be known at compilation time\",\nlabel = \"doesn't have a size known at compile-time\""}},{"Unknown":{"path":"fundamental","args":null}}],"inline":null,"rename":null,"public":true},"is_local":false,"opacity":"Foreign","lang_item":"sized"},"generics":{"regions":[],"types":[{"index":0,"name":"Self"}],"const_generics":[],"trait_clauses":[],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"parent_clauses":[],"consts":[],"const_defaults":{},"types":[],"type_defaults":{},"type_clauses":[],"methods":[]},{"def_id":2,"item_meta":{"name":[{"Ident":["core",0]},{"Ident":["fmt",0]},{"Ident":["Display",0]}],"span":{"span":{"file_id":4,"beg":{"line":724,"col":0},"end":{"line":724,"col":17}},"generated_from_span":null},"source_text":null,"attr_info":{"attributes":[{"DocComment":" Format trait for an empty format, `{}`."},{"DocComment":""},{"DocComment":" Implementing this trait for a type will automatically implement the"},{"DocComment":" [`ToString`][tostring] trait for the type, allowing the usage"},{"DocComment":" of the [`.to_string()`][tostring_function] method. Prefer implementing"},{"DocComment":" the `Display` trait for a type, rather than [`ToString`][tostring]."},{"DocComment":""},{"DocComment":" `Display` is similar to [`Debug`], but `Display` is for user-facing"},{"DocComment":" output, and so cannot be derived."},{"DocComment":""},{"DocComment":" For more information on formatters, see [the module-level documentation][module]."},{"DocComment":""},{"DocComment":" [module]: ../../std/fmt/index.html"},{"DocComment":" [tostring]: ../../std/string/trait.ToString.html"},{"DocComment":" [tostring_function]: ../../std/string/trait.ToString.html#tymethod.to_string"},{"DocComment":""},{"DocComment":" # Internationalization"},{"DocComment":""},{"DocComment":" Because a type can only have one `Display` implementation, it is often preferable"},{"DocComment":" to only implement `Display` when there is a single most \"obvious\" way that"},{"DocComment":" values can be formatted as text. This could mean formatting according to the"},{"DocComment":" \"invariant\" culture and \"undefined\" locale, or it could mean that the type"},{"DocComment":" display is designed for a specific culture/locale, such as developer logs."},{"DocComment":""},{"DocComment":" If not all values have a justifiably canonical textual format or if you want"},{"DocComment":" to support alternative formats not covered by the standard set of possible"},{"DocComment":" [formatting traits], the most flexible approach is display adapters: methods"},{"DocComment":" like [`str::escape_default`] or [`Path::display`] which create a wrapper"},{"DocComment":" implementing `Display` to output the specific display format."},{"DocComment":""},{"DocComment":" [formatting traits]: ../../std/fmt/index.html#formatting-traits"},{"DocComment":" [`Path::display`]: ../../std/path/struct.Path.html#method.display"},{"DocComment":""},{"DocComment":" # Examples"},{"DocComment":""},{"DocComment":" Implementing `Display` on a type:"},{"DocComment":""},{"DocComment":" ```"},{"DocComment":" use std::fmt;"},{"DocComment":""},{"DocComment":" struct Point {"},{"DocComment":"     x: i32,"},{"DocComment":"     y: i32,"},{"DocComment":" }"},{"DocComment":""},{"DocComment":" impl fmt::Display for Point {"},{"DocComment":"     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {"},{"DocComment":"         write!(f, \"({}, {})\", self.x, self.y)"},{"DocComment":"     }"},{"DocComment":" }"},{"DocComment":""},{"DocComment":" let origin = Point { x: 0, y: 0 };"},{"DocComment":""},{"DocComment":" assert_eq!(format!(\"The origin is: {origin}\"), \"The origin is: (0, 0)\");"},{"DocComment":" ```"},{"Unknown":{"path":"rustc_on_unimplemented","args":"on(any(_Self = \"std::path::Path\", _Self = \"std::path::PathBuf\"), label =\n\"`{Self}` cannot be formatted with the default formatter; call `.display()` on it\",\nnote =\n\"call `.display()` or `.to_string_lossy()` to safely print paths, \\\n                as they may contain non-Unicode data\"),\nmessage = \"`{Self}` doesn't implement `{Display}`\", label =\n\"`{Self}` cannot be formatted with the default formatter\", note =\n\"in format strings you may be able to use `{{:?}}` (or {{:#?}} for pretty-print) instead\""}},{"Unknown":{"path":"doc","args":"alias = \"{}\""}},{"Unknown":{"path":"rustc_diagnostic_item","args":null}}],"inline":null,"rename":null,"public":true},"is_local":false,"opacity":"Foreign","lang_item":"Display"},"generics":{"regions":[],"types":[{"index":0,"name":"Self"}],"const_generics":[],"trait_clauses":[],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"parent_clauses":[],"consts":[],"const_defaults":{},"types":[],"type_defaults":{},"type_clauses":[],"methods":[["fmt",{"params":{"regions":[{"index":0,"name":null},{"index":1,"name":null},{"index":2,"name":null}],"types":[],"const_generics":[],"trait_clauses":[],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"skip_binder":{"id":5,"generics":{"regions":[{"Var":{"Bound":[0,0]}},{"Var":{"Bound":[0,1]}},{"Var":{"Bound":[0,2]}}],"types":[{"TypeVar":{"Free":0}}],"const_generics":[],"trait_refs":[],"target":{"Item":{"Fun":5}}}},"kind":{"TraitMethod":[2,"fmt"]}}]]}],"trait_impls":[{"def_id":0,"item_meta":{"name":[{"Ident":["alloc",0]},{"Ident":["string",0]},{"Impl":[{"Trait":0},44]}],"span":{"span":{"file_id":1,"beg":{"line":2874,"col":0},"end":{"line":2874,"col":26}},"generated_from_span":null},"source_text":null,"attr_info":{"attributes":[{"Unknown":{"path":"cfg","args":"not(no_global_oom_handling)"}}],"inline":null,"rename":null,"public":false},"is_local":false,"opacity":"Foreign","lang_item":null},"impl_trait":{"trait_id":0,"generics":{"regions":[],"types":[{"Adt":[{"Adt":0},{"regions":[],"types":[],"const_generics":[],"trait_refs":[],"target":{"Item":{"Type":0}}}]},{"Ref":[{"Var":{"Free":0}},{"Adt":[{"Builtin":"Str"},{"regions":[],"types":[],"const_generics":[],"trait_refs":[],"target":"Builtin"}]},"Shared"]}],"const_generics":[],"trait_refs":[],"target":{"Item":{"TraitDecl":0}}}},"generics":{"regions":[{"index":0,"name":null}],"types":[],"const_generics":[],"trait_clauses":[],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"parent_trait_refs":[{"kind":{"BuiltinOrAuto":{"trait_decl_ref":{"regions":[],"skip_binder":{"trait_id":1,"generics":{"regions":[],"types":[{"Adt":[{"Adt":0},{"regions":[],"types":[],"const_generics":[],"trait_refs":[],"target":{"Item":{"Type":0}}}]}],"const_generics":[],"trait_refs":[],"target":{"Item":{"TraitDecl":1}}}}},"parent_trait_refs":[],"types":[]}},"trait_decl_ref":{"regions":[],"skip_binder":{"trait_id":1,"generics":{"regions":[],"types":[{"Adt":[{"Adt":0},{"regions":[],"types":[],"const_generics":[],"trait_refs":[],"target":{"Item":{"Type":0}}}]}],"const_generics":[],"trait_refs":[],"target":{"Item":{"TraitDecl":1}}}}}},{"kind":{"BuiltinOrAuto":{"trait_decl_ref":{"regions":[],"skip_binder":{"trait_id":1,"generics":{"regions":[],"types":[{"Ref":["Erased",{"Adt":[{"Builtin":"Str"},{"regions":[],"types":[],"const_generics":[],"trait_refs":[],"target":"Builtin"}]},"Shared"]}],"const_generics":[],"trait_refs":[],"target":{"Item":{"TraitDecl":1}}}}},"parent_trait_refs":[],"types":[]}},"trait_decl_ref":{"regions":[],"skip_binder":{"trait_id":1,"generics":{"regions":[],"types":[{"Ref":["Erased",{"Adt":[{"Builtin":"Str"},{"regions":[],"types":[],"const_generics":[],"trait_refs":[],"target":"Builtin"}]},"Shared"]}],"const_generics":[],"trait_refs":[],"target":{"Item":{"TraitDecl":1}}}}}}],"consts":[],"types":[],"type_clauses":[],"methods":[["from",{"params":{"regions":[],"types":[],"const_generics":[],"trait_clauses":[],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"skip_binder":{"id":7,"generics":{"regions":[{"Var":{"Free":0}}],"types":[],"const_generics":[],"trait_refs":[],"target":{"Item":{"Fun":7}}}},"kind":{"TraitMethod":[0,"from"]}}]]},{"def_id":1,"item_meta":{"name":[{"Ident":["alloc",0]},{"Ident":["string",0]},{"Impl":[{"Trait":1},21]}],"span":{"span":{"file_id":1,"beg":{"line":2495,"col":0},"end":{"line":2495,"col":28}},"generated_from_span":null},"source_text":null,"attr_info":{"attributes":[],"inline":null,"rename":null,"public":false},"is_local":false,"opacity":"Foreign","lang_item":null},"impl_trait":{"trait_id":2,"generics":{"regions":[],"types":[{"Adt":[{"Adt":0},{"regions":[],"types":[],"const_generics":[],"trait_refs":[],"target":{"Item":{"Type":0}}}]}],"const_generics":[],"trait_refs":[],"target":{"Item":{"TraitDecl":2}}}},"generics":{"regions":[],"types":[],"const_generics":[],"trait_clauses":[],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"parent_trait_refs":[],"consts":[],"types":[],"type_clauses":[],"methods":[["fmt",{"params":{"regions":[{"index":0,"name":null},{"index":1,"name":null},{"index":2,"name":null}],"types":[],"const_generics":[],"trait_clauses":[],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"skip_binder":{"id":6,"generics":{"regions":[{"Var":{"Bound":[0,0]}},{"Var":{"Bound":[0,1]}},{"Var":{"Bound":[0,2]}}],"types":[],"const_generics":[],"trait_refs":[],"target":{"Item":{"Fun":6}}}},"kind":{"TraitMethod":[2,"fmt"]}}]]}],"ordered_decls":[{"Type":{"NonRec":0}},{"Type":{"NonRec":1}},{"Type":{"NonRec":2}},{"Fun":{"NonRec":7}},{"TraitDecl":{"NonRec":1}},{"Type":{"NonRec":3}},{"Type":{"NonRec":4}},{"Type":{"NonRec":5}},{"TraitDecl":{"NonRec":2}},{"Fun":{"NonRec":2}},{"Fun":{"NonRec":6}},{"TraitImpl":{"NonRec":1}},{"Fun":{"NonRec":3}},{"Fun":{"NonRec":4}},{"Fun":{"NonRec":0}},{"Fun":{"NonRec":1}},{"TraitDecl":{"NonRec":0}},{"TraitImpl":{"NonRec":0}},{"Fun":{"NonRec":5}}]}}